Index: src/Graph.res
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>module type CONFIG = {\n  type node\n  type nodeAttr\n  type edge\n  type edgeAttr\n}\n\nmodule type GRAPH = {\n  type t\n  type node\n  type edge\n  type nodeAttr\n  type edgeAttr\n\n  let makeGraph: unit => t\n\n  // Specialized Constructors\n  let makeDirectedGraph: unit => t\n  let makeUndirectedGraph: unit => t\n  let makeMultiGraph: unit => t\n  let makeMultiDirectedGraph: unit => t\n  let makeMultiUndirectedGraph: unit => t\n\n  // Properties\n  let order: t => int\n  let size: t => int\n  let type_: t => string\n  let multi: t => bool\n  let allowSelfLoops: t => bool\n  let selfLoopCount: t => int\n  let implementation: t => string\n\n  // Read\n  let hasNode: (t, node) => bool\n  let hasEdge: (t, edge) => bool\n  let edge: (t, node, node) => edge\n  let degree: (t, node) => int\n  let degreeWithoutSelfLoops: (t, node) => int\n  let source: (t, edge) => node\n  let target: (t, edge) => node\n  let opposite: (t, node, edge) => node\n  let extremities: (t, edge) => array<node>\n  let hasExtremity: (t, edge, node) => bool\n  let isDirected: (t, edge) => bool\n  let isSelfLoop: (t, edge) => bool\n  let areNeighbors: (t, node, node) => bool\n\n  // Mutation\n  let addNode: (t, node, ~attr: nodeAttr=?) => unit\n  // todo: need to implement this\n  //  mergeNode: (t, node) => unit = \"mergeNode\"\n  let updateNode: (t, node, node => node) => (node, bool)\n  let addEdge: (t, node, node, ~attr: edgeAttr=?) => unit\n  let addEdgeWithKey: (t, edge, node, node, ~attr: edgeAttr=?) => unit\n  let mergeEdge: (t, node, node, ~attr: edgeAttr=?) => (edge, bool, bool, bool)\n  let mergeEdgeWithKey: (t, edge, node, node, ~attr: edgeAttr=?) => (edge, bool, bool, bool)\n  let updateEdge: (t, node, node, edgeAttr => edgeAttr) => (edge, bool, bool, bool)\n  let updateEdgeWithKey: (t, edge, node, node, edgeAttr => edgeAttr) => (edge, bool, bool, bool)\n\n  let dropEdge: (t, edge) => unit\n  let dropNode: (t, node) => unit\n\n  let clear: t => unit\n  let clearEdges: t => unit\n\n  // todo:Attributes\n\n  // Iteration\n  // Nodes Iteration\n  let nodes: t => array<node>\n  let forEachNode: (t, (node, nodeAttr) => unit) => unit\n  let mapNodes: (t, (node, nodeAttr) => 'a) => array<'a>\n  let filterNodes: (t, (node, nodeAttr) => bool) => array<node>\n  let reduceNodes: (t, ('a, node, nodeAttr) => 'a, 'a) => array<node>\n  let findNode: (t, (node, nodeAttr) => bool) => node\n  let someNode: (t, (node, nodeAttr) => bool) => bool\n  let everyNode: (t, (node, nodeAttr) => bool) => bool\n\n  type nodeIterValue = {node: node, attributes: nodeAttr}\n  let nodeEntries: t => RescriptCore.Iterator.t<nodeIterValue>\n\n  // Edges Iteration\n  let edges: t => array<edge>\n  let forEachEdge: (t, (edge, edgeAttr) => unit) => unit\n  let mapEdges: (t, (edge, edgeAttr) => 'a) => array<'a>\n  let filterEdges: (t, (edge, edgeAttr) => bool) => array<edge>\n  let reduceEdges: (t, ('a, edge, edgeAttr) => 'a, 'a) => array<edge>\n  let findEdge: (t, (edge, edgeAttr) => bool) => edge\n  let someEdge: (t, (edge, edgeAttr) => bool) => bool\n  let everyEdge: (t, (edge, edgeAttr) => bool) => bool\n\n  type edgeIterValue = {edge: edge, attributes: edgeAttr}\n  let edgeEntries: t => RescriptCore.Iterator.t<edgeIterValue>\n\n  // Neighbors Iteration\n  let neighbors: t => array<node>\n  let forEachNeighbor: (t, (node, nodeAttr) => unit) => unit\n  let mapNeighbors: (t, (node, nodeAttr) => 'a) => array<'a>\n  let filterNeighbors: (t, (node, nodeAttr) => bool) => array<node>\n\n  let reduceNeighbors: (t, ('a, node, nodeAttr) => 'a, 'a) => array<node>\n  let findNeighbor: (t, (node, nodeAttr) => bool) => node\n  let someNeighbor: (t, (node, nodeAttr) => bool) => bool\n  let everyNeighbor: (t, (node, nodeAttr) => bool) => bool\n  let neighborEntries: t => RescriptCore.Iterator.t<nodeIterValue>\n\n  // Known methods\n  let inspect: t => string\n\n  // Standard Libraries\n  module ShortestPath: {\n    module Unweighted: {\n      // Unweighted\n      // todo: result might be null if no path found and raises Error exception. how to handle it\n      let bidirectional: (t, node, node) => array<node>\n\n      // todo: result is a map like :  { '1': [ '1' ], '2': [ '1', '2' ], '3': [ '1', '2', '3' ] } how to handle it?\n      let singleSource: (t, node) => 'a\n\n      // todo: result is a map\n      let singleSourceLength: (t, node) => 'a\n\n      // todo: result is a map\n      let undirectedSingleSourceLength: (t, node) => 'a\n    }\n\n    module Dijkstra: {\n      // todo: result might be null if no path found and raises Error exception. how to handle it\n      // todo: optiona getEdgeWeight arg is not supported yet\n      let bidirectional: (t, node, node) => array<node>\n\n      // todo: result is a map like :  { '1': [ '1' ], '2': [ '1', '2' ], '3': [ '1', '2', '3' ] } how to handle it?\n      // todo: optiona getEdgeWeight arg is not supported yet\n      let singleSource: (t, node) => 'a\n    }\n\n    module Utils: {\n      let edgePathFromNodePath: (t, array<node>) => array<edge>\n    }\n  }\n\n  module SimplePath: {\n    type opts\n    let allSimplePaths: (t, node, node, ~opts: opts=?) => array<array<node>>\n    let allSimpleEdgePaths: (t, node, node, ~opts: opts=?) => array<array<edge>>\n    let allSimpleEdgeGroupPaths: (t, node, node, ~opts: opts=?) => array<array<array<node>>>\n  }\n\n  module Traversal: {\n    let bfs: (t, (node, nodeAttr, int) => unit) => unit\n    let bfsFromNode: (t, node, (node, nodeAttr, int) => unit) => unit\n    let dfs: (t, (node, nodeAttr, int) => unit) => unit\n    let dfsFromNode: (t, node, (node, nodeAttr, int) => unit) => unit\n  }\n}\n\nmodule type MAKE_GRAPH = (C: CONFIG) =>\n(\n  GRAPH\n    with type node = C.node\n    and type nodeAttr = C.nodeAttr\n    and type edge = C.edge\n    and type edgeAttr = C.edgeAttr\n)\n\nmodule MakeGraph: MAKE_GRAPH = (C: CONFIG) => {\n  type t\n  type node = C.node\n  type edge = C.edge\n  type nodeAttr = C.nodeAttr\n  type edgeAttr = C.edgeAttr\n\n  @new @module(\"graphology\") @scope(\"default\") external makeGraph: unit => t = \"Graph\"\n\n  // Specialized Constructors\n  @new @module(\"graphology\") @scope(\"default\")\n  external makeDirectedGraph: unit => t = \"DirectedGraph\"\n  @new @module(\"graphology\") @scope(\"default\")\n  external makeUndirectedGraph: unit => t = \"UndirectedGraph\"\n  @new @module(\"graphology\") @scope(\"default\") external makeMultiGraph: unit => t = \"MultiGraph\"\n  @new @module(\"graphology\")\n  external makeMultiDirectedGraph: unit => t = \"MultiDirectedGraph\"\n  @new @module(\"graphology\")\n  external makeMultiUndirectedGraph: unit => t = \"MultiUndirectedGraph\"\n\n  @get external order: t => int = \"order\"\n  @get external size: t => int = \"size\"\n  @get external type_: t => string = \"type\"\n  @get external multi: t => bool = \"multi\"\n  @get external allowSelfLoops: t => bool = \"allowSelfLoops\"\n  @get external selfLoopCount: t => int = \"selfLoopCount\"\n  @get external implementation: t => string = \"implementation\"\n\n  @send external hasNode: (t, node) => bool = \"hasNode\"\n  @send external hasEdge: (t, edge) => bool = \"hasEdge\"\n  @send external edge: (t, node, node) => edge = \"edge\"\n  @send external degree: (t, node) => int = \"degree\"\n  @send external degreeWithoutSelfLoops: (t, node) => int = \"degreeWithoutSelfLoops\"\n  @send external source: (t, edge) => node = \"source\"\n  @send external target: (t, edge) => node = \"target\"\n  @send external opposite: (t, node, edge) => node = \"opposite\"\n  @send external extremities: (t, edge) => array<node> = \"extremities\"\n  @send external hasExtremity: (t, edge, node) => bool = \"hasExtremity\"\n  @send external isDirected: (t, edge) => bool = \"isDirected\"\n  @send external isSelfLoop: (t, edge) => bool = \"isSelfLoop\"\n  @send external areNeighbors: (t, node, node) => bool = \"areNeighbors\"\n\n  // Mutation\n  @send external addNode: (t, node, ~attr: nodeAttr=?) => unit = \"addNode\"\n  // todo: need to implement this\n  //  @send external mergeNode: (t, node) => unit = \"mergeNode\"\n  @send external updateNode: (t, node, node => node) => (node, bool) = \"updateNode\"\n\n  @send external addEdge: (t, node, node, ~attr: edgeAttr=?) => unit = \"addEdge\"\n  @send\n  external addEdgeWithKey: (t, edge, node, node, ~attr: edgeAttr=?) => unit = \"addEdgeWithKey\"\n  @send\n  external mergeEdge: (t, node, node, ~attr: edgeAttr=?) => (edge, bool, bool, bool) = \"mergeEdge\"\n  external mergeEdgeWithKey: (t, edge, node, node, ~attr: edgeAttr=?) => (edge, bool, bool, bool) =\n    \"mergeEdgeWithKey\"\n  external updateEdge: (t, node, node, edgeAttr => edgeAttr) => (edge, bool, bool, bool) =\n    \"updateEdge\"\n  external updateEdgeWithKey: (\n    t,\n    edge,\n    node,\n    node,\n    edgeAttr => edgeAttr,\n  ) => (edge, bool, bool, bool) = \"updateEdgeWithKey\"\n\n  @send external dropNode: (t, node) => unit = \"dropNode\"\n  @send external dropEdge: (t, edge) => unit = \"dropEdge\"\n\n  @send external clear: t => unit = \"clear\"\n  @send external clearEdges: t => unit = \"clearEdges\"\n\n  // Iteration\n  // Nodes Iteration\n  @send external nodes: t => array<node> = \"nodes\"\n  @send external forEachNode: (t, (node, nodeAttr) => unit) => unit = \"forEachNode\"\n  @send external mapNodes: (t, (node, nodeAttr) => 'a) => array<'a> = \"mapNodes\"\n  @send external filterNodes: (t, (node, nodeAttr) => bool) => array<node> = \"filterNodes\"\n  @send external reduceNodes: (t, ('a, node, nodeAttr) => 'a, 'a) => array<node> = \"reduceNodes\"\n  @send external findNode: (t, (node, nodeAttr) => bool) => node = \"findNode\"\n  @send external someNode: (t, (node, nodeAttr) => bool) => bool = \"someNode\"\n  @send external everyNode: (t, (node, nodeAttr) => bool) => bool = \"everyNode\"\n  type nodeIterValue = {node: node, attributes: nodeAttr}\n  @send external nodeEntries: t => Core__Iterator.t<nodeIterValue> = \"nodeEntries\"\n\n  // Edges Iteration\n  @send external edges: t => array<edge> = \"edges\"\n  @send external forEachEdge: (t, (edge, edgeAttr) => unit) => unit = \"forEachEdge\"\n  @send external mapEdges: (t, (edge, edgeAttr) => 'a) => array<'a> = \"mapEdges\"\n  @send external filterEdges: (t, (edge, edgeAttr) => bool) => array<edge> = \"filterEdges\"\n  @send external reduceEdges: (t, ('a, edge, edgeAttr) => 'a, 'a) => array<edge> = \"reduceEdges\"\n  @send external findEdge: (t, (edge, edgeAttr) => bool) => edge = \"findEdge\"\n  @send external someEdge: (t, (edge, edgeAttr) => bool) => bool = \"someEdge\"\n  @send external everyEdge: (t, (edge, edgeAttr) => bool) => bool = \"everyEdge\"\n  type edgeIterValue = {edge: edge, attributes: edgeAttr}\n  @send external edgeEntries: t => Core__Iterator.t<edgeIterValue> = \"edgeEntries\"\n\n  // Neighbors Iteration\n  @send external neighbors: t => array<node> = \"neighbors\"\n  @send external forEachNeighbor: (t, (node, nodeAttr) => unit) => unit = \"forEachNeighbor\"\n  @send external mapNeighbors: (t, (node, nodeAttr) => 'a) => array<'a> = \"mapNeighbors\"\n  @send external filterNeighbors: (t, (node, nodeAttr) => bool) => array<node> = \"filterNeighbors\"\n  @send\n  external reduceNeighbors: (t, ('a, node, nodeAttr) => 'a, 'a) => array<node> = \"reduceNeighbors\"\n  @send external findNeighbor: (t, (node, nodeAttr) => bool) => node = \"findNeighbor\"\n  @send external someNeighbor: (t, (node, nodeAttr) => bool) => bool = \"someNeighbor\"\n  @send external everyNeighbor: (t, (node, nodeAttr) => bool) => bool = \"everyNeighbor\"\n  @send external neighborEntries: t => Core__Iterator.t<nodeIterValue> = \"neighborEntries\"\n\n  // Known methods\n  @send external inspect: t => string = \"inspect\"\n\n  //\n  // Graphology Stand Libraries\n  //\n  module ShortestPath = {\n    module Unweighted = {\n      // Unweighted\n      // todo: result might be null if no path found and raises Error exception. how to handle it\n      @module(\"graphology-shortest-path\") @scope(\"unweighted\")\n      external bidirectional: (t, node, node) => array<node> = \"bidirectional\"\n\n      // todo: result is a map like :  { '1': [ '1' ], '2': [ '1', '2' ], '3': [ '1', '2', '3' ] } how to handle it?\n      @module(\"graphology-shortest-path\") @scope(\"unweighted\")\n      external singleSource: (t, node) => 'a = \"singleSource\"\n\n      // todo: result is a map\n      @module(\"graphology-shortest-path\") @scope(\"unweighted\")\n      external singleSourceLength: (t, node) => 'a = \"singleSourceLength\"\n\n      // todo: result is a map\n      @module(\"graphology-shortest-path\") @scope(\"unweighted\")\n      external undirectedSingleSourceLength: (t, node) => 'a = \"undirectedSingleSourceLength\"\n    }\n\n    module Dijkstra = {\n      // todo: result might be null if no path found and raises Error exception. how to handle it\n      // todo: optiona getEdgeWeight arg is not supported yet\n      @module(\"graphology-shortest-path\") @scope(\"dijkstra\")\n      external bidirectional: (t, node, node) => array<node> = \"bidirectional\"\n\n      // todo: result is a map like :  { '1': [ '1' ], '2': [ '1', '2' ], '3': [ '1', '2', '3' ] } how to handle it?\n      // todo: optiona getEdgeWeight arg is not supported yet\n      @module(\"graphology-shortest-path\") @scope(\"dijkstra\")\n      external singleSource: (t, node) => 'a = \"singleSource\"\n    }\n\n    module Utils = {\n      @module(\"graphology-shortest-path\") @scope(\"utils\")\n      external edgePathFromNodePath: (t, array<node>) => array<edge> = \"edgePathFromNodePath\"\n    }\n  }\n\n  module SimplePath = {\n    type opts = {maxDepth?: int}\n\n    @module(\"graphology-simple-path\")\n    external allSimplePaths: (t, node, node, ~opts: opts=?) => array<array<node>> = \"allSimplePaths\"\n\n    @module(\"graphology-simple-path\")\n    external allSimpleEdgePaths: (t, node, node, ~opts: opts=?) => array<array<edge>> =\n      \"allSimpleEdgePaths\"\n\n    @module(\"graphology-simple-path\")\n    external allSimpleEdgeGroupPaths: (t, node, node, ~opts: opts=?) => array<array<array<node>>> =\n      \"allSimpleEdgeGroupPaths\"\n  }\n\n  module Traversal = {\n    // todo: the option arg is not supported yet\n    @module(\"graphology-traversal\")\n    external bfs: (t, (node, nodeAttr, int) => unit) => unit = \"bfs\"\n\n    @module(\"graphology-traversal\")\n    external bfsFromNode: (t, node, (node, nodeAttr, int) => unit) => unit = \"bfsFromNode\"\n\n    @module(\"graphology-traversal\")\n    external dfs: (t, (node, nodeAttr, int) => unit) => unit = \"dfs\"\n\n    @module(\"graphology-traversal\")\n    external dfsFromNode: (t, node, (node, nodeAttr, int) => unit) => unit = \"dfsFromNode\"\n  }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/Graph.res b/src/Graph.res
--- a/src/Graph.res	(revision 7a67181e8c6464081e00e4d4efdb79837708e990)
+++ b/src/Graph.res	(date 1707562763801)
@@ -113,15 +113,9 @@
       // Unweighted
       // todo: result might be null if no path found and raises Error exception. how to handle it
       let bidirectional: (t, node, node) => array<node>
-
-      // todo: result is a map like :  { '1': [ '1' ], '2': [ '1', '2' ], '3': [ '1', '2', '3' ] } how to handle it?
-      let singleSource: (t, node) => 'a
-
-      // todo: result is a map
-      let singleSourceLength: (t, node) => 'a
-
-      // todo: result is a map
-      let undirectedSingleSourceLength: (t, node) => 'a
+      let singleSource: (t, node) => RescriptCore.Dict.t<array<node>>
+      let singleSourceLength: (t, node) => RescriptCore.Dict.t<int>
+      let undirectedSingleSourceLength: (t, node) => RescriptCore.Dict.t<int>
     }
 
     module Dijkstra: {
@@ -130,8 +124,8 @@
       let bidirectional: (t, node, node) => array<node>
 
       // todo: result is a map like :  { '1': [ '1' ], '2': [ '1', '2' ], '3': [ '1', '2', '3' ] } how to handle it?
-      // todo: optiona getEdgeWeight arg is not supported yet
-      let singleSource: (t, node) => 'a
+      // todo: optional getEdgeWeight arg is not supported yet
+      let singleSource: (t, node) => RescriptCore.Dict.t<array<node>>
     }
 
     module Utils: {
@@ -286,15 +280,14 @@
 
       // todo: result is a map like :  { '1': [ '1' ], '2': [ '1', '2' ], '3': [ '1', '2', '3' ] } how to handle it?
       @module("graphology-shortest-path") @scope("unweighted")
-      external singleSource: (t, node) => 'a = "singleSource"
+      external singleSource: (t, node) => RescriptCore.Dict.t<array<node>> = "singleSource"
 
-      // todo: result is a map
       @module("graphology-shortest-path") @scope("unweighted")
-      external singleSourceLength: (t, node) => 'a = "singleSourceLength"
+      external singleSourceLength: (t, node) => RescriptCore.Dict.t<int> = "singleSourceLength"
 
-      // todo: result is a map
       @module("graphology-shortest-path") @scope("unweighted")
-      external undirectedSingleSourceLength: (t, node) => 'a = "undirectedSingleSourceLength"
+      external undirectedSingleSourceLength: (t, node) => RescriptCore.Dict.t<int> =
+        "undirectedSingleSourceLength"
     }
 
     module Dijkstra = {
@@ -306,7 +299,7 @@
       // todo: result is a map like :  { '1': [ '1' ], '2': [ '1', '2' ], '3': [ '1', '2', '3' ] } how to handle it?
       // todo: optiona getEdgeWeight arg is not supported yet
       @module("graphology-shortest-path") @scope("dijkstra")
-      external singleSource: (t, node) => 'a = "singleSource"
+      external singleSource: (t, node) => RescriptCore.Dict.t<array<node>> = "singleSource"
     }
 
     module Utils = {
