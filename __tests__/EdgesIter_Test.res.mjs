// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Jest from "@glennsl/rescript-jest/src/jest.res.mjs";
import * as Graphology__Graph from "../src/Graphology__Graph.res.mjs";

Jest.describe("Graph - Edges Iterator", () => {
  let G = Graphology__Graph.MakeGraph({});
  Jest.describe("edges", () => {
    Jest.test("returns empty array for graph without edges", () => {
      let g = G.makeDirectedGraph();
      G.addNode(g, "A", undefined);
      G.addNode(g, "B", undefined);
      return Jest.Expect.toEqual(Jest.Expect.expect(G.EdgesIter.edges(g, "All")), []);
    });
    Jest.test("returns all edges with All arg", () => {
      let g = G.makeDirectedGraph();
      G.addNode(g, "A", undefined);
      G.addNode(g, "B", undefined);
      G.addNode(g, "C", undefined);
      G.addEdgeWithKey(g, "e1", "A", "B", undefined);
      G.addEdgeWithKey(g, "e2", "B", "C", undefined);
      let result = G.EdgesIter.edges(g, "All");
      let hasE1 = result.includes("e1");
      let hasE2 = result.includes("e2");
      return Jest.Expect.toEqual(Jest.Expect.expect([
        result.length,
        hasE1,
        hasE2
      ]), [
        2,
        true,
        true
      ]);
    });
    Jest.test("returns edges for specific node", () => {
      let g = G.makeDirectedGraph();
      G.addNode(g, "A", undefined);
      G.addNode(g, "B", undefined);
      G.addNode(g, "C", undefined);
      G.addEdgeWithKey(g, "e1", "A", "B", undefined);
      G.addEdgeWithKey(g, "e2", "B", "C", undefined);
      let result = G.EdgesIter.edges(g, {
        TAG: "Node",
        _0: "B"
      });
      return Jest.Expect.toBe(Jest.Expect.expect(result.length), 2);
    });
    Jest.test("returns edges between two nodes", () => {
      let g = G.makeDirectedGraph();
      G.addNode(g, "A", undefined);
      G.addNode(g, "B", undefined);
      G.addEdgeWithKey(g, "e1", "A", "B", undefined);
      let result = G.EdgesIter.edges(g, {
        TAG: "FromTo",
        _0: "A",
        _1: "B"
      });
      return Jest.Expect.toEqual(Jest.Expect.expect(result), ["e1"]);
    });
  });
  Jest.describe("inEdges and outEdges", () => {
    Jest.test("distinguishes between incoming and outgoing edges", () => {
      let g = G.makeDirectedGraph();
      G.addNode(g, "A", undefined);
      G.addNode(g, "B", undefined);
      G.addNode(g, "C", undefined);
      G.addEdgeWithKey(g, "e1", "A", "B", undefined);
      G.addEdgeWithKey(g, "e2", "C", "B", undefined);
      let inEdges = G.EdgesIter.inEdges(g, {
        TAG: "Node",
        _0: "B"
      });
      let outEdges = G.EdgesIter.outEdges(g, {
        TAG: "Node",
        _0: "B"
      });
      return Jest.Expect.toEqual(Jest.Expect.expect([
        inEdges.length,
        outEdges.length
      ]), [
        2,
        0
      ]);
    });
    Jest.test("handles outgoing edges correctly", () => {
      let g = G.makeDirectedGraph();
      G.addNode(g, "A", undefined);
      G.addNode(g, "B", undefined);
      G.addNode(g, "C", undefined);
      G.addEdgeWithKey(g, "e1", "A", "B", undefined);
      G.addEdgeWithKey(g, "e2", "A", "C", undefined);
      let result = G.EdgesIter.outEdges(g, {
        TAG: "Node",
        _0: "A"
      });
      let hasE1 = result.includes("e1");
      let hasE2 = result.includes("e2");
      return Jest.Expect.toEqual(Jest.Expect.expect([
        result.length,
        hasE1,
        hasE2
      ]), [
        2,
        true,
        true
      ]);
    });
  });
  Jest.describe("directedEdges and undirectedEdges", () => {
    Jest.test("returns all directed edges in directed graph", () => {
      let g = G.makeDirectedGraph();
      G.addNode(g, "A", undefined);
      G.addNode(g, "B", undefined);
      G.addNode(g, "C", undefined);
      G.addEdgeWithKey(g, "e1", "A", "B", undefined);
      G.addEdgeWithKey(g, "e2", "B", "C", undefined);
      let result = G.EdgesIter.directedEdges(g, "All");
      let hasE1 = result.includes("e1");
      let hasE2 = result.includes("e2");
      return Jest.Expect.toEqual(Jest.Expect.expect([
        result.length,
        hasE1,
        hasE2
      ]), [
        2,
        true,
        true
      ]);
    });
    Jest.test("returns all undirected edges in undirected graph", () => {
      let g = G.makeUndirectedGraph();
      G.addNode(g, "A", undefined);
      G.addNode(g, "B", undefined);
      G.addNode(g, "C", undefined);
      G.addEdgeWithKey(g, "e1", "A", "B", undefined);
      G.addEdgeWithKey(g, "e2", "B", "C", undefined);
      let result = G.EdgesIter.undirectedEdges(g, "All");
      return Jest.Expect.toBe(Jest.Expect.expect(result.length), 2);
    });
  });
  Jest.describe("forEachEdge", () => {
    Jest.test("iterates over all edges", () => {
      let g = G.makeDirectedGraph();
      G.addNode(g, "A", undefined);
      G.addNode(g, "B", undefined);
      G.addNode(g, "C", undefined);
      G.addEdgeWithKey(g, "e1", "A", "B", undefined);
      G.addEdgeWithKey(g, "e2", "B", "C", undefined);
      let count = {
        contents: 0
      };
      G.EdgesIter.forEachEdge(g, {
        TAG: "All",
        _0: (_edge, _attr, _source, _target, _sAttr, _tAttr, _undirected) => {
          count.contents = count.contents + 1 | 0;
        }
      });
      return Jest.Expect.toBe(Jest.Expect.expect(count.contents), 2);
    });
    Jest.test("provides edge details", () => {
      let g = G.makeDirectedGraph();
      G.addNode(g, "A", undefined);
      G.addNode(g, "B", undefined);
      G.addEdgeWithKey(g, "e1", "A", "B", {
        weight: 5
      });
      let edgeKey = {
        contents: ""
      };
      let weight = {
        contents: 0
      };
      let source = {
        contents: ""
      };
      let target = {
        contents: ""
      };
      G.EdgesIter.forEachEdge(g, {
        TAG: "All",
        _0: (edge, attr, src, tgt, _sAttr, _tAttr, _undirected) => {
          edgeKey.contents = edge;
          weight.contents = attr.weight;
          source.contents = src;
          target.contents = tgt;
        }
      });
      return Jest.Expect.toEqual(Jest.Expect.expect([
        edgeKey.contents,
        weight.contents,
        source.contents,
        target.contents
      ]), [
        "e1",
        5,
        "A",
        "B"
      ]);
    });
    Jest.test("iterates over edges of specific node", () => {
      let g = G.makeDirectedGraph();
      G.addNode(g, "A", undefined);
      G.addNode(g, "B", undefined);
      G.addNode(g, "C", undefined);
      G.addEdgeWithKey(g, "e1", "A", "B", undefined);
      G.addEdgeWithKey(g, "e2", "B", "C", undefined);
      G.addEdgeWithKey(g, "e3", "C", "A", undefined);
      let count = {
        contents: 0
      };
      G.EdgesIter.forEachEdge(g, {
        TAG: "Node",
        _0: "B",
        _1: (_edge, _attr, _source, _target, _sAttr, _tAttr, _undirected) => {
          count.contents = count.contents + 1 | 0;
        }
      });
      return Jest.Expect.toBe(Jest.Expect.expect(count.contents), 2);
    });
  });
  Jest.describe("mapEdges", () => {
    Jest.test("maps over all edges", () => {
      let g = G.makeDirectedGraph();
      G.addNode(g, "A", undefined);
      G.addNode(g, "B", undefined);
      G.addNode(g, "C", undefined);
      G.addEdgeWithKey(g, "e1", "A", "B", undefined);
      G.addEdgeWithKey(g, "e2", "B", "C", undefined);
      let result = G.EdgesIter.mapEdges(g, {
        TAG: "All",
        _0: (edge, _attr, _source, _target, _sAttr, _tAttr, _undirected) => edge
      });
      let hasE1 = result.includes("e1");
      let hasE2 = result.includes("e2");
      return Jest.Expect.toEqual(Jest.Expect.expect([
        result.length,
        hasE1,
        hasE2
      ]), [
        2,
        true,
        true
      ]);
    });
    Jest.test("transforms edge data", () => {
      let g = G.makeDirectedGraph();
      G.addNode(g, "A", undefined);
      G.addNode(g, "B", undefined);
      G.addEdgeWithKey(g, "e1", "A", "B", {
        weight: 10
      });
      G.addEdgeWithKey(g, "e2", "B", "A", {
        weight: 20
      });
      let result = G.EdgesIter.mapEdges(g, {
        TAG: "All",
        _0: (_edge, _attr, source, target, _sAttr, _tAttr, _undirected) => source + "->" + target
      });
      let hasAB = result.includes("A->B");
      let hasBA = result.includes("B->A");
      return Jest.Expect.toEqual(Jest.Expect.expect([
        result.length,
        hasAB,
        hasBA
      ]), [
        2,
        true,
        true
      ]);
    });
    Jest.test("returns empty array for graph without edges", () => {
      let g = G.makeDirectedGraph();
      G.addNode(g, "A", undefined);
      let result = G.EdgesIter.mapEdges(g, {
        TAG: "All",
        _0: (edge, _attr, _source, _target, _sAttr, _tAttr, _undirected) => edge
      });
      return Jest.Expect.toEqual(Jest.Expect.expect(result), []);
    });
  });
  Jest.describe("filterEdges", () => {
    Jest.test("filters edges by predicate", () => {
      let g = G.makeDirectedGraph();
      G.addNode(g, "A", undefined);
      G.addNode(g, "B", undefined);
      G.addNode(g, "C", undefined);
      G.addEdgeWithKey(g, "e1", "A", "B", {
        weight: 5
      });
      G.addEdgeWithKey(g, "e2", "B", "C", {
        weight: 15
      });
      G.addEdgeWithKey(g, "e3", "C", "A", {
        weight: 8
      });
      let result = G.EdgesIter.filterEdges(g, {
        TAG: "All",
        _0: (_edge, attr, _source, _target, _sAttr, _tAttr, _undirected) => attr.weight > 10
      });
      return Jest.Expect.toEqual(Jest.Expect.expect(result), ["e2"]);
    });
    Jest.test("filters by source node", () => {
      let g = G.makeDirectedGraph();
      G.addNode(g, "A", undefined);
      G.addNode(g, "B", undefined);
      G.addNode(g, "C", undefined);
      G.addEdgeWithKey(g, "e1", "A", "B", undefined);
      G.addEdgeWithKey(g, "e2", "B", "C", undefined);
      G.addEdgeWithKey(g, "e3", "A", "C", undefined);
      let result = G.EdgesIter.filterEdges(g, {
        TAG: "All",
        _0: (_edge, _attr, source, _target, _sAttr, _tAttr, _undirected) => source === "A"
      });
      let hasE1 = result.includes("e1");
      let hasE3 = result.includes("e3");
      return Jest.Expect.toEqual(Jest.Expect.expect([
        result.length,
        hasE1,
        hasE3
      ]), [
        2,
        true,
        true
      ]);
    });
    Jest.test("returns all edges when predicate is true", () => {
      let g = G.makeDirectedGraph();
      G.addNode(g, "A", undefined);
      G.addNode(g, "B", undefined);
      G.addEdgeWithKey(g, "e1", "A", "B", undefined);
      let result = G.EdgesIter.filterEdges(g, {
        TAG: "All",
        _0: (_edge, _attr, _source, _target, _sAttr, _tAttr, _undirected) => true
      });
      return Jest.Expect.toBe(Jest.Expect.expect(result.length), 1);
    });
    Jest.test("returns empty array when predicate is false", () => {
      let g = G.makeDirectedGraph();
      G.addNode(g, "A", undefined);
      G.addNode(g, "B", undefined);
      G.addEdgeWithKey(g, "e1", "A", "B", undefined);
      let result = G.EdgesIter.filterEdges(g, {
        TAG: "All",
        _0: (_edge, _attr, _source, _target, _sAttr, _tAttr, _undirected) => false
      });
      return Jest.Expect.toEqual(Jest.Expect.expect(result), []);
    });
  });
  Jest.describe("reduceEdges", () => {
    Jest.test("reduces edges to single value", () => {
      let g = G.makeDirectedGraph();
      G.addNode(g, "A", undefined);
      G.addNode(g, "B", undefined);
      G.addNode(g, "C", undefined);
      G.addEdgeWithKey(g, "e1", "A", "B", {
        weight: 10
      });
      G.addEdgeWithKey(g, "e2", "B", "C", {
        weight: 20
      });
      G.addEdgeWithKey(g, "e3", "C", "A", {
        weight: 15
      });
      let total = G.EdgesIter.reduceEdges(g, {
        TAG: "All",
        _0: (acc, _edge, attr, _source, _target, _sAttr, _tAttr, _undirected) => acc + attr.weight | 0,
        _1: 0
      });
      return Jest.Expect.toBe(Jest.Expect.expect(total), 45);
    });
    Jest.test("accumulates edge keys", () => {
      let g = G.makeDirectedGraph();
      G.addNode(g, "A", undefined);
      G.addNode(g, "B", undefined);
      G.addNode(g, "C", undefined);
      G.addEdgeWithKey(g, "e1", "A", "B", undefined);
      G.addEdgeWithKey(g, "e2", "B", "C", undefined);
      let keys = G.EdgesIter.reduceEdges(g, {
        TAG: "All",
        _0: (acc, edge, _attr, _source, _target, _sAttr, _tAttr, _undirected) => acc.concat([edge]),
        _1: []
      });
      let hasE1 = keys.includes("e1");
      let hasE2 = keys.includes("e2");
      return Jest.Expect.toEqual(Jest.Expect.expect([
        keys.length,
        hasE1,
        hasE2
      ]), [
        2,
        true,
        true
      ]);
    });
    Jest.test("returns initial value for empty graph", () => {
      let g = G.makeDirectedGraph();
      G.addNode(g, "A", undefined);
      let result = G.EdgesIter.reduceEdges(g, {
        TAG: "All",
        _0: (acc, _edge, _attr, _source, _target, _sAttr, _tAttr, _undirected) => acc + 1 | 0,
        _1: 0
      });
      return Jest.Expect.toBe(Jest.Expect.expect(result), 0);
    });
  });
  Jest.describe("someEdge", () => {
    Jest.test("returns true if any edge matches", () => {
      let g = G.makeDirectedGraph();
      G.addNode(g, "A", undefined);
      G.addNode(g, "B", undefined);
      G.addNode(g, "C", undefined);
      G.addEdgeWithKey(g, "e1", "A", "B", {
        weight: 5
      });
      G.addEdgeWithKey(g, "e2", "B", "C", {
        weight: 15
      });
      let result = G.EdgesIter.someEdge(g, {
        TAG: "All",
        _0: (_edge, attr, _source, _target, _sAttr, _tAttr, _undirected) => attr.weight > 10
      });
      return Jest.Expect.toBe(Jest.Expect.expect(result), true);
    });
    Jest.test("returns false if no edge matches", () => {
      let g = G.makeDirectedGraph();
      G.addNode(g, "A", undefined);
      G.addNode(g, "B", undefined);
      G.addEdgeWithKey(g, "e1", "A", "B", {
        weight: 5
      });
      let result = G.EdgesIter.someEdge(g, {
        TAG: "All",
        _0: (_edge, attr, _source, _target, _sAttr, _tAttr, _undirected) => attr.weight > 10
      });
      return Jest.Expect.toBe(Jest.Expect.expect(result), false);
    });
    Jest.test("returns false for empty graph", () => {
      let g = G.makeDirectedGraph();
      G.addNode(g, "A", undefined);
      let result = G.EdgesIter.someEdge(g, {
        TAG: "All",
        _0: (_edge, _attr, _source, _target, _sAttr, _tAttr, _undirected) => true
      });
      return Jest.Expect.toBe(Jest.Expect.expect(result), false);
    });
  });
  Jest.describe("everyEdge", () => {
    Jest.test("returns true if all edges match", () => {
      let g = G.makeDirectedGraph();
      G.addNode(g, "A", undefined);
      G.addNode(g, "B", undefined);
      G.addNode(g, "C", undefined);
      G.addEdgeWithKey(g, "e1", "A", "B", {
        weight: 15
      });
      G.addEdgeWithKey(g, "e2", "B", "C", {
        weight: 20
      });
      let result = G.EdgesIter.everyEdge(g, {
        TAG: "All",
        _0: (_edge, attr, _source, _target, _sAttr, _tAttr, _undirected) => attr.weight > 10
      });
      return Jest.Expect.toBe(Jest.Expect.expect(result), true);
    });
    Jest.test("returns false if any edge doesn't match", () => {
      let g = G.makeDirectedGraph();
      G.addNode(g, "A", undefined);
      G.addNode(g, "B", undefined);
      G.addNode(g, "C", undefined);
      G.addEdgeWithKey(g, "e1", "A", "B", {
        weight: 5
      });
      G.addEdgeWithKey(g, "e2", "B", "C", {
        weight: 20
      });
      let result = G.EdgesIter.everyEdge(g, {
        TAG: "All",
        _0: (_edge, attr, _source, _target, _sAttr, _tAttr, _undirected) => attr.weight > 10
      });
      return Jest.Expect.toBe(Jest.Expect.expect(result), false);
    });
    Jest.test("returns true for empty graph", () => {
      let g = G.makeDirectedGraph();
      G.addNode(g, "A", undefined);
      let result = G.EdgesIter.everyEdge(g, {
        TAG: "All",
        _0: (_edge, _attr, _source, _target, _sAttr, _tAttr, _undirected) => false
      });
      return Jest.Expect.toBe(Jest.Expect.expect(result), true);
    });
  });
  Jest.describe("edgeEntries", () => {
    Jest.test("returns iterator for empty graph", () => {
      let g = G.makeDirectedGraph();
      G.addNode(g, "A", undefined);
      let iter = G.EdgesIter.edgeEntries(g, "All");
      let next = iter.next();
      return Jest.Expect.toBe(Jest.Expect.expect(next.done), true);
    });
    Jest.test("iterates over edge entries", () => {
      let g = G.makeDirectedGraph();
      G.addNode(g, "A", undefined);
      G.addNode(g, "B", undefined);
      G.addNode(g, "C", undefined);
      G.addEdgeWithKey(g, "e1", "A", "B", undefined);
      G.addEdgeWithKey(g, "e2", "B", "C", undefined);
      let iter = G.EdgesIter.edgeEntries(g, "All");
      let edges = [];
      let collect = () => {
        while (true) {
          let next = iter.next();
          if (next.done) {
            return;
          }
          let entry = next.value;
          if (entry === undefined) {
            return;
          }
          edges.push(entry.edge);
          continue;
        };
      };
      collect();
      let hasE1 = edges.includes("e1");
      let hasE2 = edges.includes("e2");
      return Jest.Expect.toEqual(Jest.Expect.expect([
        edges.length,
        hasE1,
        hasE2
      ]), [
        2,
        true,
        true
      ]);
    });
    Jest.test("provides edge details", () => {
      let g = G.makeDirectedGraph();
      G.addNode(g, "A", undefined);
      G.addNode(g, "B", undefined);
      G.addEdgeWithKey(g, "e1", "A", "B", {
        weight: 10
      });
      let iter = G.EdgesIter.edgeEntries(g, "All");
      let next = iter.next();
      let entry = next.value;
      if (entry !== undefined) {
        return Jest.Expect.toEqual(Jest.Expect.expect([
          next.done,
          entry.edge,
          entry.source,
          entry.target,
          entry.attributes.weight
        ]), [
          false,
          "e1",
          "A",
          "B",
          10
        ]);
      } else {
        return Jest.fail("Expected entry value");
      }
    });
    Jest.test("iterates over edges of specific node", () => {
      let g = G.makeDirectedGraph();
      G.addNode(g, "A", undefined);
      G.addNode(g, "B", undefined);
      G.addNode(g, "C", undefined);
      G.addEdgeWithKey(g, "e1", "A", "B", undefined);
      G.addEdgeWithKey(g, "e2", "B", "C", undefined);
      G.addEdgeWithKey(g, "e3", "C", "A", undefined);
      let iter = G.EdgesIter.edgeEntries(g, {
        TAG: "Node",
        _0: "B"
      });
      let count = {
        contents: 0
      };
      let iterate = () => {
        while (true) {
          let next = iter.next();
          if (next.done) {
            return;
          }
          count.contents = count.contents + 1 | 0;
          continue;
        };
      };
      iterate();
      return Jest.Expect.toBe(Jest.Expect.expect(count.contents), 2);
    });
  });
  Jest.describe("Integration Tests", () => {
    Jest.test("combines multiple edge iteration methods", () => {
      let g = G.makeDirectedGraph();
      G.addNode(g, "A", undefined);
      G.addNode(g, "B", undefined);
      G.addNode(g, "C", undefined);
      G.addEdgeWithKey(g, "e1", "A", "B", {
        weight: 5,
        active: true
      });
      G.addEdgeWithKey(g, "e2", "B", "C", {
        weight: 15,
        active: false
      });
      G.addEdgeWithKey(g, "e3", "C", "A", {
        weight: 10,
        active: true
      });
      let activeEdges = G.EdgesIter.filterEdges(g, {
        TAG: "All",
        _0: (_edge, attr, _source, _target, _sAttr, _tAttr, _undirected) => attr.active === true
      });
      let hasHeavyEdge = G.EdgesIter.someEdge(g, {
        TAG: "All",
        _0: (_edge, attr, _source, _target, _sAttr, _tAttr, _undirected) => attr.weight > 10
      });
      let allEdges = G.EdgesIter.edges(g, "All");
      return Jest.Expect.toEqual(Jest.Expect.expect([
        activeEdges.length,
        hasHeavyEdge,
        allEdges.length
      ]), [
        2,
        true,
        3
      ]);
    });
    Jest.test("works with undirected graph", () => {
      let g = G.makeUndirectedGraph();
      G.addNode(g, "A", undefined);
      G.addNode(g, "B", undefined);
      G.addNode(g, "C", undefined);
      G.addEdgeWithKey(g, "e1", "A", "B", undefined);
      G.addEdgeWithKey(g, "e2", "B", "C", undefined);
      let edges = G.EdgesIter.edges(g, "All");
      let undirectedEdges = G.EdgesIter.undirectedEdges(g, "All");
      return Jest.Expect.toEqual(Jest.Expect.expect([
        edges.length,
        undirectedEdges.length
      ]), [
        2,
        2
      ]);
    });
    Jest.test("works with multi-directed graph", () => {
      let g = G.makeMultiDirectedGraph();
      G.addNode(g, "A", undefined);
      G.addNode(g, "B", undefined);
      G.addEdgeWithKey(g, "e1", "A", "B", undefined);
      G.addEdgeWithKey(g, "e2", "A", "B", undefined);
      let allEdges = G.EdgesIter.edges(g, "All");
      let directed = G.EdgesIter.directedEdges(g, "All");
      return Jest.Expect.toEqual(Jest.Expect.expect([
        allEdges.length,
        directed.length
      ]), [
        2,
        2
      ]);
    });
  });
});

/*  Not a pure module */
