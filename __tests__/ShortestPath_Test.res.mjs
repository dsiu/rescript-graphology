// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Jest from "@glennsl/rescript-jest/src/jest.res.mjs";
import * as Pervasives from "@rescript/runtime/lib/es6/Pervasives.js";
import * as Graphology__Graph from "../src/Graphology__Graph.res.mjs";

Jest.describe("ShortestPath - Unweighted", () => {
  let G = Graphology__Graph.MakeGraph({});
  let createTestGraph = () => {
    let g = G.makeGraph(undefined);
    G.addNode(g, "A", undefined);
    G.addNode(g, "B", undefined);
    G.addNode(g, "C", undefined);
    G.addNode(g, "D", undefined);
    G.addNode(g, "E", undefined);
    G.addEdge(g, "A", "B", undefined);
    G.addEdge(g, "B", "C", undefined);
    G.addEdge(g, "A", "D", undefined);
    G.addEdge(g, "D", "E", undefined);
    G.addEdge(g, "E", "C", undefined);
    return g;
  };
  Jest.test("finds bidirectional shortest path", () => {
    let g = createTestGraph();
    let path = G.ShortestPath.Unweighted.bidirectional(g, "A", "C");
    return Jest.Expect.toEqual(Jest.Expect.expect(path), [
      "A",
      "B",
      "C"
    ]);
  });
  Jest.test("finds single source shortest paths", () => {
    let g = createTestGraph();
    let paths = G.ShortestPath.Unweighted.singleSource(g, "A");
    let pathA = paths["A"];
    let pathB = paths["B"];
    let pathC = paths["C"];
    return Jest.Expect.toEqual(Jest.Expect.expect([
      pathA,
      pathB,
      pathC
    ]), [
      ["A"],
      [
        "A",
        "B"
      ],
      [
        "A",
        "B",
        "C"
      ]
    ]);
  });
  Jest.test("calculates single source path lengths", () => {
    let g = createTestGraph();
    let lengths = G.ShortestPath.Unweighted.singleSourceLength(g, "A");
    let lenA = lengths["A"];
    let lenB = lengths["B"];
    let lenC = lengths["C"];
    return Jest.Expect.toEqual(Jest.Expect.expect([
      lenA,
      lenB,
      lenC
    ]), [
      0,
      1,
      2
    ]);
  });
  Jest.test("handles unreachable nodes", () => {
    let g = G.makeGraph(undefined);
    G.addNode(g, "A", undefined);
    G.addNode(g, "B", undefined);
    G.addNode(g, "C", undefined);
    G.addEdge(g, "A", "B", undefined);
    let paths = G.ShortestPath.Unweighted.singleSource(g, "A");
    return Jest.Expect.toEqual(Jest.Expect.expect(paths["C"]), undefined);
  });
});

Jest.describe("ShortestPath - Dijkstra", () => {
  let G = Graphology__Graph.MakeGraph({});
  let createWeightedGraph = () => {
    let g = G.makeGraph(undefined);
    G.addNode(g, "A", undefined);
    G.addNode(g, "B", undefined);
    G.addNode(g, "C", undefined);
    G.addNode(g, "D", undefined);
    G.addEdge(g, "A", "B", {
      weight: 1
    });
    G.addEdge(g, "B", "C", {
      weight: 2
    });
    G.addEdge(g, "A", "D", {
      weight: 4
    });
    G.addEdge(g, "D", "C", {
      weight: 1
    });
    return g;
  };
  Jest.test("finds weighted shortest path with attribute", () => {
    let g = createWeightedGraph();
    let path = G.ShortestPath.Dijkstra.bidirectional(g, "A", "C", {
      NAME: "Attr",
      VAL: "weight"
    });
    return Jest.Expect.toEqual(Jest.Expect.expect(path), [
      "A",
      "B",
      "C"
    ]);
  });
  Jest.test("finds all shortest paths from single source", () => {
    let g = createWeightedGraph();
    let paths = G.ShortestPath.Dijkstra.singleSource(g, "A", undefined);
    let pathA = paths["A"];
    let pathB = paths["B"];
    let numPaths = Object.keys(paths).length;
    return Jest.Expect.toEqual(Jest.Expect.expect([
      pathA,
      pathB,
      numPaths
    ]), [
      ["A"],
      [
        "A",
        "B"
      ],
      4
    ]);
  });
  Jest.test("handles graphs with different weights", () => {
    let g = G.makeGraph(undefined);
    G.addNode(g, "A", undefined);
    G.addNode(g, "B", undefined);
    G.addNode(g, "C", undefined);
    G.addEdge(g, "A", "B", {
      weight: 10
    });
    G.addEdge(g, "B", "C", {
      weight: 1
    });
    G.addEdge(g, "A", "C", {
      weight: 5
    });
    let path = G.ShortestPath.Dijkstra.bidirectional(g, "A", "C", {
      NAME: "Attr",
      VAL: "weight"
    });
    return Jest.Expect.toEqual(Jest.Expect.expect(path), [
      "A",
      "C"
    ]);
  });
  Jest.test("works with uniform weights", () => {
    let g = G.makeGraph(undefined);
    G.addNode(g, "A", undefined);
    G.addNode(g, "B", undefined);
    G.addNode(g, "C", undefined);
    G.addEdge(g, "A", "B", undefined);
    G.addEdge(g, "B", "C", undefined);
    G.addEdge(g, "A", "C", undefined);
    let path = G.ShortestPath.Dijkstra.bidirectional(g, "A", "C", undefined);
    if (path == null) {
      return Jest.fail("Expected to find a path");
    } else {
      return Jest.Expect.toBeLessThanOrEqual(Jest.Expect.expect(path.length), 2);
    }
  });
});

Jest.describe("ShortestPath - A*", () => {
  let G = Graphology__Graph.MakeGraph({});
  let createGridGraph = () => {
    let g = G.makeGraph(undefined);
    G.addNode(g, [
      0,
      0
    ], undefined);
    G.addNode(g, [
      0,
      1
    ], undefined);
    G.addNode(g, [
      1,
      0
    ], undefined);
    G.addNode(g, [
      1,
      1
    ], undefined);
    G.addEdge(g, [
      0,
      0
    ], [
      0,
      1
    ], undefined);
    G.addEdge(g, [
      0,
      0
    ], [
      1,
      0
    ], undefined);
    G.addEdge(g, [
      0,
      1
    ], [
      1,
      1
    ], undefined);
    G.addEdge(g, [
      1,
      0
    ], [
      1,
      1
    ], undefined);
    return g;
  };
  Jest.test("finds path with heuristic", () => {
    let g = createGridGraph();
    let heuristic = (param, param$1) => Pervasives.abs(param$1[0] - param[0] | 0) + Pervasives.abs(param$1[1] - param[1] | 0) | 0;
    G.ShortestPath.AStar.bidirectional(g, [
      0,
      0
    ], [
      1,
      1
    ], undefined, heuristic);
    return Jest.Expect.toBe(Jest.Expect.expect(true), true);
  });
});

Jest.describe("ShortestPath - Utils", () => {
  let G = Graphology__Graph.MakeGraph({});
  Jest.test("converts node path to edge path", () => {
    let g = G.makeGraph(undefined);
    G.addNode(g, "A", undefined);
    G.addNode(g, "B", undefined);
    G.addNode(g, "C", undefined);
    G.addNode(g, "D", undefined);
    G.addEdgeWithKey(g, "e1", "A", "B", undefined);
    G.addEdgeWithKey(g, "e2", "B", "C", undefined);
    G.addEdgeWithKey(g, "e3", "C", "D", undefined);
    let nodePath = [
      "A",
      "B",
      "C",
      "D"
    ];
    let edgePath = G.ShortestPath.Utils.edgePathFromNodePath(g, nodePath);
    return Jest.Expect.toEqual(Jest.Expect.expect(edgePath), [
      "e1",
      "e2",
      "e3"
    ]);
  });
  Jest.test("handles empty node path", () => {
    let g = G.makeGraph(undefined);
    G.addNode(g, "A", undefined);
    let nodePath = [];
    try {
      let edgePath = G.ShortestPath.Utils.edgePathFromNodePath(g, nodePath);
      return Jest.Expect.toBe(Jest.Expect.expect(edgePath.length), 0);
    } catch (exn) {
      return Jest.Expect.toBe(Jest.Expect.expect(true), true);
    }
  });
  Jest.test("handles single node path", () => {
    let g = G.makeGraph(undefined);
    G.addNode(g, "A", undefined);
    let nodePath = ["A"];
    let edgePath = G.ShortestPath.Utils.edgePathFromNodePath(g, nodePath);
    return Jest.Expect.toBe(Jest.Expect.expect(edgePath.length), 0);
  });
});

/*  Not a pure module */
