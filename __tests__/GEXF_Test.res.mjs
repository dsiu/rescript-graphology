// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Jest from "@glennsl/rescript-jest/src/jest.res.mjs";
import * as Graphology__Graph from "../src/Graphology__Graph.res.mjs";

Jest.describe("GEXF - Write/Export", () => {
  let G = Graphology__Graph.MakeGraph({});
  Jest.test("exports graph to GEXF string", () => {
    let g = G.makeGraph(undefined);
    G.addNode(g, "A", undefined);
    G.addNode(g, "B", undefined);
    G.addEdge(g, "A", "B", undefined);
    let gexfStr = G.GEXF.write(g, undefined);
    let hasLength = gexfStr.length > 0;
    let hasXml = gexfStr.includes("<?xml");
    let hasGexf = gexfStr.includes("gexf");
    return Jest.Expect.toEqual(Jest.Expect.expect([
      hasLength,
      hasXml,
      hasGexf
    ]), [
      true,
      true,
      true
    ]);
  });
  Jest.test("exports with version option", () => {
    let g = G.makeGraph(undefined);
    G.addNode(g, "A", undefined);
    let gexfStr = G.GEXF.write(g, {
      version: "1.3"
    });
    return Jest.Expect.toBe(Jest.Expect.expect(gexfStr.includes("1.3")), true);
  });
  Jest.test("exports with custom node formatter", () => {
    let g = G.makeGraph(undefined);
    G.addNode(g, "A", {
      name: "Alice",
      age: 30
    });
    let gexfStr = G.GEXF.write(g, {
      formatNode: (key, attributes) => ({
        label: key,
        attributes: {
          name: attributes.name
        }
      }),
      version: "1.3"
    });
    return Jest.Expect.toBe(Jest.Expect.expect(gexfStr.includes("Alice")), true);
  });
  Jest.test("exports with custom edge formatter", () => {
    let g = G.makeGraph(undefined);
    G.addNode(g, "A", undefined);
    G.addNode(g, "B", undefined);
    G.addEdge(g, "A", "B", {
      weight: 5
    });
    let gexfStr = G.GEXF.write(g, {
      formatEdge: (_key, attributes) => ({
        weight: attributes.weight
      }),
      version: "1.3"
    });
    return Jest.Expect.toBeGreaterThan(Jest.Expect.expect(gexfStr.length), 0);
  });
  Jest.test("exports empty graph", () => {
    let g = G.makeGraph(undefined);
    let gexfStr = G.GEXF.write(g, undefined);
    let hasXml = gexfStr.includes("<?xml");
    let hasGexf = gexfStr.includes("gexf");
    return Jest.Expect.toEqual(Jest.Expect.expect([
      hasXml,
      hasGexf
    ]), [
      true,
      true
    ]);
  });
  Jest.test("exports graph with attributes", () => {
    let g = G.makeGraph(undefined);
    G.setAttribute(g, "name", "TestGraph");
    G.addNode(g, "A", undefined);
    G.addNode(g, "B", undefined);
    let gexfStr = G.GEXF.write(g, undefined);
    return Jest.Expect.toBeGreaterThan(Jest.Expect.expect(gexfStr.length), 0);
  });
  Jest.test("exports multi-graph", () => {
    let g = G.makeGraph({
      multi: true
    });
    G.addNode(g, "A", undefined);
    G.addNode(g, "B", undefined);
    G.addEdgeWithKey(g, "e1", "A", "B", undefined);
    G.addEdgeWithKey(g, "e2", "A", "B", undefined);
    let gexfStr = G.GEXF.write(g, undefined);
    return Jest.Expect.toBeGreaterThan(Jest.Expect.expect(gexfStr.length), 0);
  });
  Jest.test("handles directed graph", () => {
    let g = G.makeDirectedGraph();
    G.addNode(g, "A", undefined);
    G.addNode(g, "B", undefined);
    G.addEdge(g, "A", "B", undefined);
    let gexfStr = G.GEXF.write(g, undefined);
    return Jest.Expect.toBe(Jest.Expect.expect(gexfStr.includes("directed")), true);
  });
  Jest.test("handles undirected graph", () => {
    let g = G.makeUndirectedGraph();
    G.addNode(g, "A", undefined);
    G.addNode(g, "B", undefined);
    G.addEdge(g, "A", "B", undefined);
    let gexfStr = G.GEXF.write(g, undefined);
    return Jest.Expect.toBe(Jest.Expect.expect(gexfStr.includes("undirected")), true);
  });
  Jest.test("handles graph with only nodes", () => {
    let g = G.makeGraph(undefined);
    G.addNode(g, "A", undefined);
    G.addNode(g, "B", undefined);
    G.addNode(g, "C", undefined);
    let gexfStr = G.GEXF.write(g, undefined);
    let hasNodes = gexfStr.includes("<nodes");
    let hasEdges = gexfStr.includes("<edges");
    return Jest.Expect.toEqual(Jest.Expect.expect([
      hasNodes,
      hasEdges
    ]), [
      true,
      true
    ]);
  });
});

/*  Not a pure module */
