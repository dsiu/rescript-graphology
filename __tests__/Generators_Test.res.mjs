// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Jest from "@glennsl/rescript-jest/src/jest.res.mjs";
import * as Graphology__Graph from "../src/Graphology__Graph.res.mjs";

Jest.describe("Generators - Classic Graphs", () => {
  let G = Graphology__Graph.MakeGraph({});
  Jest.test("creates complete graph with correct edges", () => {
    let g = G.Generators.complete("UndirectedGraph", 5);
    let order = G.order(g);
    let size = G.size(g);
    return Jest.Expect.toEqual(Jest.Expect.expect([
      order,
      size
    ]), [
      5,
      10
    ]);
  });
  Jest.test("creates empty graph with no edges", () => {
    let g = G.Generators.empty("Graph", 5);
    let order = G.order(g);
    let size = G.size(g);
    return Jest.Expect.toEqual(Jest.Expect.expect([
      order,
      size
    ]), [
      5,
      0
    ]);
  });
  Jest.test("creates ladder graph", () => {
    let g = G.Generators.ladder("UndirectedGraph", 4);
    let order = G.order(g);
    return Jest.Expect.toBe(Jest.Expect.expect(order), 8);
  });
  Jest.test("creates path graph", () => {
    let g = G.Generators.path("UndirectedGraph", 5);
    let order = G.order(g);
    let size = G.size(g);
    return Jest.Expect.toEqual(Jest.Expect.expect([
      order,
      size
    ]), [
      5,
      4
    ]);
  });
  Jest.test("creates directed complete graph", () => {
    let g = G.Generators.complete("DirectedGraph", 4);
    let order = G.order(g);
    let type_ = G.type_(g);
    return Jest.Expect.toEqual(Jest.Expect.expect([
      order,
      type_
    ]), [
      4,
      "directed"
    ]);
  });
  Jest.test("creates multi graph", () => {
    let g = G.Generators.complete("MultiGraph", 3);
    let isMulti = G.multi(g);
    return Jest.Expect.toBe(Jest.Expect.expect(isMulti), true);
  });
});

Jest.describe("Generators - Community Graphs", () => {
  let G = Graphology__Graph.MakeGraph({});
  Jest.test("creates caveman graph", () => {
    let g = G.Generators.caveman("UndirectedGraph", 3, 4);
    let order = G.order(g);
    return Jest.Expect.toBe(Jest.Expect.expect(order), 12);
  });
  Jest.test("creates connected caveman graph", () => {
    let g = G.Generators.connectedCaveman("UndirectedGraph", 3, 4);
    let order = G.order(g);
    return Jest.Expect.toBe(Jest.Expect.expect(order), 12);
  });
  Jest.test("caveman graph has correct structure", () => {
    let g = G.Generators.caveman("UndirectedGraph", 2, 3);
    let order = G.order(g);
    let size = G.size(g);
    return Jest.Expect.toEqual(Jest.Expect.expect([
      order,
      size
    ]), [
      6,
      6
    ]);
  });
});

Jest.describe("Generators - Random Graphs", () => {
  let G = Graphology__Graph.MakeGraph({});
  Jest.test("creates clusters graph", () => {
    let g = G.Generators.clusters("UndirectedGraph", {
      order: 20,
      size: 30,
      clusters: 3
    });
    let order = G.order(g);
    let size = G.size(g);
    let sizeIsReasonable = size >= 20 && size <= 40;
    return Jest.Expect.toEqual(Jest.Expect.expect([
      order,
      sizeIsReasonable
    ]), [
      20,
      true
    ]);
  });
  Jest.test("creates clusters with custom density", () => {
    let g = G.Generators.clusters("UndirectedGraph", {
      order: 15,
      size: 20,
      clusters: 2,
      clusterDensity: 0.7
    });
    let order = G.order(g);
    return Jest.Expect.toBe(Jest.Expect.expect(order), 15);
  });
  Jest.test("creates Erdos-Renyi graph", () => {
    let g = G.Generators.erdosRenyi("UndirectedGraph", {
      order: 10,
      probability: 0.3,
      approximateSize: 0
    });
    let order = G.order(g);
    return Jest.Expect.toBe(Jest.Expect.expect(order), 10);
  });
  Jest.test("creates Girvan-Newman graph", () => {
    let g = G.Generators.girvanNewman("UndirectedGraph", {
      zOut: 5
    });
    let order = G.order(g);
    return Jest.Expect.toBe(Jest.Expect.expect(order), 128);
  });
  Jest.test("random graphs respect graph type", () => {
    let g = G.Generators.erdosRenyi("DirectedGraph", {
      order: 10,
      probability: 0.2,
      approximateSize: 0
    });
    let type_ = G.type_(g);
    return Jest.Expect.toBe(Jest.Expect.expect(type_), "directed");
  });
});

Jest.describe("Generators - Small Graphs", () => {
  let G = Graphology__Graph.MakeGraph({});
  Jest.test("creates Krackhardt Kite graph", () => {
    let g = G.Generators.krackhardtKite("UndirectedGraph");
    let order = G.order(g);
    let size = G.size(g);
    return Jest.Expect.toEqual(Jest.Expect.expect([
      order,
      size
    ]), [
      10,
      18
    ]);
  });
  Jest.test("Krackhardt Kite respects graph type", () => {
    let g = G.Generators.krackhardtKite("DirectedGraph");
    let type_ = G.type_(g);
    return Jest.Expect.toBe(Jest.Expect.expect(type_), "directed");
  });
});

Jest.describe("Generators - Social Graphs", () => {
  let G = Graphology__Graph.MakeGraph({});
  Jest.test("creates Florentine Families graph", () => {
    let g = G.Generators.florentineFamilies("UndirectedGraph");
    let order = G.order(g);
    let size = G.size(g);
    return Jest.Expect.toEqual(Jest.Expect.expect([
      order,
      size
    ]), [
      15,
      20
    ]);
  });
  Jest.test("creates Karate Club graph", () => {
    let g = G.Generators.karateClub("UndirectedGraph");
    let order = G.order(g);
    let size = G.size(g);
    return Jest.Expect.toEqual(Jest.Expect.expect([
      order,
      size
    ]), [
      34,
      78
    ]);
  });
  Jest.test("social graphs respect graph type", () => {
    let g = G.Generators.karateClub("DirectedGraph");
    let type_ = G.type_(g);
    return Jest.Expect.toBe(Jest.Expect.expect(type_), "directed");
  });
});

Jest.describe("Generators - Integration Tests", () => {
  let G = Graphology__Graph.MakeGraph({});
  Jest.test("generated graph can be traversed", () => {
    let g = G.Generators.complete("UndirectedGraph", 5);
    let visited = [];
    G.Traversal.bfs(g, (node, _attr, _depth) => {
      visited.push(node);
    });
    return Jest.Expect.toBe(Jest.Expect.expect(visited.length), 5);
  });
  Jest.test("generated graph can have layout applied", () => {
    let g = G.Generators.path("UndirectedGraph", 4);
    G.Layout.Circular.assign(g, undefined);
    let hasX = G.NodesIter.everyNode(g, (node, _attr) => G.hasNodeAttribute(g, node, "x"));
    let hasY = G.NodesIter.everyNode(g, (node, _attr) => G.hasNodeAttribute(g, node, "y"));
    return Jest.Expect.toEqual(Jest.Expect.expect([
      hasX,
      hasY
    ]), [
      true,
      true
    ]);
  });
  Jest.test("generated graph can calculate shortest path", () => {
    let g = G.Generators.path("UndirectedGraph", 5);
    let nodes = G.NodesIter.nodes(g);
    let firstNode = nodes[0];
    let lastNode = nodes[nodes.length - 1 | 0];
    let path = G.ShortestPath.Unweighted.bidirectional(g, firstNode, lastNode);
    return Jest.Expect.toBe(Jest.Expect.expect(path.length), 5);
  });
  Jest.test("can combine multiple generator outputs", () => {
    let g1 = G.Generators.path("UndirectedGraph", 3);
    let g2 = G.Generators.complete("UndirectedGraph", 2);
    let order1 = G.order(g1);
    let order2 = G.order(g2);
    return Jest.Expect.toEqual(Jest.Expect.expect([
      order1,
      order2
    ]), [
      3,
      2
    ]);
  });
});

/*  Not a pure module */
