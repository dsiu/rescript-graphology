// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Jest from "@glennsl/rescript-jest/src/jest.res.mjs";
import * as Graphology__Graph from "../src/Graphology__Graph.res.mjs";

Jest.describe("Traversal - BFS (Breadth-First Search)", () => {
  let G = Graphology__Graph.MakeGraph({});
  let createTreeGraph = () => {
    let g = G.makeGraph(undefined);
    G.addNode(g, "1", undefined);
    G.addNode(g, "2", undefined);
    G.addNode(g, "3", undefined);
    G.addNode(g, "4", undefined);
    G.addNode(g, "5", undefined);
    G.addEdge(g, "1", "2", undefined);
    G.addEdge(g, "1", "3", undefined);
    G.addEdge(g, "2", "4", undefined);
    G.addEdge(g, "2", "5", undefined);
    return g;
  };
  Jest.test("visits nodes in BFS order", () => {
    let g = createTreeGraph();
    let visited = [];
    G.Traversal.bfs(g, (node, _attr, _depth) => {
      visited.push(node);
    });
    let visitedCount = visited.length;
    let firstNode = visited[0];
    return Jest.Expect.toEqual(Jest.Expect.expect([
      visitedCount,
      firstNode
    ]), [
      5,
      "1"
    ]);
  });
  Jest.test("provides correct depth information", () => {
    let g = createTreeGraph();
    let depths = {};
    G.Traversal.bfs(g, (node, _attr, depth) => {
      depths[node] = depth;
    });
    let depth1 = depths["1"];
    let depth2 = depths["2"];
    let depth3 = depths["3"];
    let depth4 = depths["4"];
    let depth5 = depths["5"];
    return Jest.Expect.toEqual(Jest.Expect.expect([
      depth1,
      depth2,
      depth3,
      depth4,
      depth5
    ]), [
      0,
      1,
      1,
      2,
      2
    ]);
  });
  Jest.test("BFS from specific node", () => {
    let g = createTreeGraph();
    let visited = [];
    G.Traversal.bfsFromNode(g, "2", (node, _attr, _depth) => {
      visited.push(node);
    });
    let has1 = visited.includes("1");
    let has2 = visited.includes("2");
    let has4 = visited.includes("4");
    let has5 = visited.includes("5");
    return Jest.Expect.toEqual(Jest.Expect.expect([
      has1,
      has2,
      has4,
      has5
    ]), [
      false,
      true,
      true,
      true
    ]);
  });
  Jest.test("handles disconnected graph", () => {
    let g = G.makeGraph(undefined);
    G.addNode(g, "A", undefined);
    G.addNode(g, "B", undefined);
    G.addNode(g, "C", undefined);
    G.addEdge(g, "A", "B", undefined);
    let visited = [];
    G.Traversal.bfsFromNode(g, "A", (node, _attr, _depth) => {
      visited.push(node);
    });
    return Jest.Expect.toBe(Jest.Expect.expect(visited.includes("C")), false);
  });
});

Jest.describe("Traversal - DFS (Depth-First Search)", () => {
  let G = Graphology__Graph.MakeGraph({});
  let createTreeGraph = () => {
    let g = G.makeGraph(undefined);
    G.addNode(g, "1", undefined);
    G.addNode(g, "2", undefined);
    G.addNode(g, "3", undefined);
    G.addNode(g, "4", undefined);
    G.addNode(g, "5", undefined);
    G.addEdge(g, "1", "2", undefined);
    G.addEdge(g, "1", "3", undefined);
    G.addEdge(g, "2", "4", undefined);
    G.addEdge(g, "2", "5", undefined);
    return g;
  };
  Jest.test("visits nodes in DFS order", () => {
    let g = createTreeGraph();
    let visited = [];
    G.Traversal.dfs(g, (node, _attr, _depth) => {
      visited.push(node);
    });
    let visitedCount = visited.length;
    let firstNode = visited[0];
    return Jest.Expect.toEqual(Jest.Expect.expect([
      visitedCount,
      firstNode
    ]), [
      5,
      "1"
    ]);
  });
  Jest.test("provides correct depth information", () => {
    let g = createTreeGraph();
    let maxDepth = {
      contents: 0
    };
    G.Traversal.dfs(g, (_node, _attr, depth) => {
      if (depth > maxDepth.contents) {
        maxDepth.contents = depth;
        return;
      }
    });
    return Jest.Expect.toBe(Jest.Expect.expect(maxDepth.contents), 2);
  });
  Jest.test("DFS from specific node", () => {
    let g = createTreeGraph();
    let visited = [];
    G.Traversal.dfsFromNode(g, "2", (node, _attr, _depth) => {
      visited.push(node);
    });
    let has1 = visited.includes("1");
    let has2 = visited.includes("2");
    let has4 = visited.includes("4");
    let has5 = visited.includes("5");
    return Jest.Expect.toEqual(Jest.Expect.expect([
      has1,
      has2,
      has4,
      has5
    ]), [
      false,
      true,
      true,
      true
    ]);
  });
  Jest.test("handles graph with cycle", () => {
    let g = G.makeGraph(undefined);
    G.addNode(g, "A", undefined);
    G.addNode(g, "B", undefined);
    G.addNode(g, "C", undefined);
    G.addEdge(g, "A", "B", undefined);
    G.addEdge(g, "B", "C", undefined);
    G.addEdge(g, "C", "A", undefined);
    let visited = [];
    G.Traversal.dfsFromNode(g, "A", (node, _attr, _depth) => {
      visited.push(node);
    });
    let visitedCount = visited.length;
    let uniqueNodes = new Set(visited);
    let uniqueCount = uniqueNodes.size;
    return Jest.Expect.toEqual(Jest.Expect.expect([
      visitedCount,
      uniqueCount
    ]), [
      3,
      3
    ]);
  });
});

Jest.describe("Traversal - Comparison BFS vs DFS", () => {
  let G = Graphology__Graph.MakeGraph({});
  Jest.test("BFS and DFS visit all nodes in different orders", () => {
    let g = G.makeGraph(undefined);
    G.addNode(g, "1", undefined);
    G.addNode(g, "2", undefined);
    G.addNode(g, "3", undefined);
    G.addNode(g, "4", undefined);
    G.addEdge(g, "1", "2", undefined);
    G.addEdge(g, "1", "3", undefined);
    G.addEdge(g, "2", "4", undefined);
    let bfsOrder = [];
    let dfsOrder = [];
    G.Traversal.bfs(g, (node, _attr, _depth) => {
      bfsOrder.push(node);
    });
    G.Traversal.dfs(g, (node, _attr, _depth) => {
      dfsOrder.push(node);
    });
    let bfsCount = bfsOrder.length;
    let dfsCount = dfsOrder.length;
    let bfsUnique = new Set(bfsOrder).size;
    let dfsUnique = new Set(dfsOrder).size;
    return Jest.Expect.toEqual(Jest.Expect.expect([
      bfsCount,
      dfsCount,
      bfsUnique,
      dfsUnique
    ]), [
      4,
      4,
      4,
      4
    ]);
  });
});

Jest.describe("Traversal - Edge Cases", () => {
  let G = Graphology__Graph.MakeGraph({});
  Jest.test("handles single node graph", () => {
    let g = G.makeGraph(undefined);
    G.addNode(g, "A", undefined);
    let visited = [];
    G.Traversal.bfs(g, (node, _attr, _depth) => {
      visited.push(node);
    });
    return Jest.Expect.toEqual(Jest.Expect.expect(visited), ["A"]);
  });
  Jest.test("handles empty graph", () => {
    let g = G.makeGraph(undefined);
    let visited = [];
    G.Traversal.bfs(g, (node, _attr, _depth) => {
      visited.push(node);
    });
    return Jest.Expect.toBe(Jest.Expect.expect(visited.length), 0);
  });
  Jest.test("handles linear graph", () => {
    let g = G.makeGraph(undefined);
    G.addNode(g, "A", undefined);
    G.addNode(g, "B", undefined);
    G.addNode(g, "C", undefined);
    G.addEdge(g, "A", "B", undefined);
    G.addEdge(g, "B", "C", undefined);
    let bfsOrder = [];
    G.Traversal.bfsFromNode(g, "A", (node, _attr, depth) => {
      bfsOrder.push([
        node,
        depth
      ]);
    });
    return Jest.Expect.toEqual(Jest.Expect.expect(bfsOrder), [
      [
        "A",
        0
      ],
      [
        "B",
        1
      ],
      [
        "C",
        2
      ]
    ]);
  });
});

/*  Not a pure module */
