// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Jest from "@glennsl/rescript-jest/src/jest.res.mjs";
import * as Graphology__Graph from "../src/Graphology__Graph.res.mjs";

Jest.describe("Graph - Nodes Iterator", () => {
  let G = Graphology__Graph.MakeGraph({});
  Jest.describe("nodes", () => {
    Jest.test("returns empty array for empty graph", () => {
      let g = G.makeGraph(undefined);
      return Jest.Expect.toEqual(Jest.Expect.expect(G.NodesIter.nodes(g)), []);
    });
    Jest.test("returns all node keys", () => {
      let g = G.makeGraph(undefined);
      G.addNode(g, "Alice", undefined);
      G.addNode(g, "Bob", undefined);
      G.addNode(g, "Charlie", undefined);
      let nodeList = G.NodesIter.nodes(g);
      let hasAlice = nodeList.includes("Alice");
      let hasBob = nodeList.includes("Bob");
      let hasCharlie = nodeList.includes("Charlie");
      return Jest.Expect.toEqual(Jest.Expect.expect([
        nodeList.length,
        hasAlice,
        hasBob,
        hasCharlie
      ]), [
        3,
        true,
        true,
        true
      ]);
    });
    Jest.test("reflects current graph state", () => {
      let g = G.makeGraph(undefined);
      G.addNode(g, "Alice", undefined);
      G.addNode(g, "Bob", undefined);
      let initialCount = G.NodesIter.nodes(g).length;
      G.dropNode(g, "Alice");
      let afterDrop = G.NodesIter.nodes(g);
      return Jest.Expect.toEqual(Jest.Expect.expect([
        initialCount,
        afterDrop.length,
        afterDrop
      ]), [
        2,
        1,
        ["Bob"]
      ]);
    });
  });
  Jest.describe("forEachNode", () => {
    Jest.test("iterates over all nodes", () => {
      let g = G.makeGraph(undefined);
      G.addNode(g, "Alice", {
        age: 30
      });
      G.addNode(g, "Bob", {
        age: 25
      });
      G.addNode(g, "Charlie", {
        age: 35
      });
      let count = {
        contents: 0
      };
      G.NodesIter.forEachNode(g, (_node, _attr) => {
        count.contents = count.contents + 1 | 0;
      });
      return Jest.Expect.toBe(Jest.Expect.expect(count.contents), 3);
    });
    Jest.test("provides node attributes", () => {
      let g = G.makeGraph(undefined);
      G.addNode(g, "Alice", {
        age: 30,
        city: "NYC"
      });
      let age = {
        contents: 0
      };
      let city = {
        contents: ""
      };
      G.NodesIter.forEachNode(g, (_node, attr) => {
        age.contents = attr.age;
        city.contents = attr.city;
      });
      return Jest.Expect.toEqual(Jest.Expect.expect([
        age.contents,
        city.contents
      ]), [
        30,
        "NYC"
      ]);
    });
    Jest.test("does nothing for empty graph", () => {
      let g = G.makeGraph(undefined);
      let count = {
        contents: 0
      };
      G.NodesIter.forEachNode(g, (_node, _attr) => {
        count.contents = count.contents + 1 | 0;
      });
      return Jest.Expect.toBe(Jest.Expect.expect(count.contents), 0);
    });
    Jest.test("can modify node attributes during iteration", () => {
      let g = G.makeGraph(undefined);
      G.addNode(g, "Alice", {
        score: 10
      });
      G.addNode(g, "Bob", {
        score: 20
      });
      G.NodesIter.forEachNode(g, (node, attr) => {
        let newScore = attr.score + 5 | 0;
        G.setNodeAttribute(g, node, "score", newScore);
      });
      let aliceScore = G.getNodeAttribute(g, "Alice", "score");
      let bobScore = G.getNodeAttribute(g, "Bob", "score");
      return Jest.Expect.toEqual(Jest.Expect.expect([
        aliceScore,
        bobScore
      ]), [
        15,
        25
      ]);
    });
  });
  Jest.describe("mapNodes", () => {
    Jest.test("maps over all nodes", () => {
      let g = G.makeGraph(undefined);
      G.addNode(g, "Alice", undefined);
      G.addNode(g, "Bob", undefined);
      G.addNode(g, "Charlie", undefined);
      let result = G.NodesIter.mapNodes(g, (node, _attr) => node);
      let hasAlice = result.includes("Alice");
      let hasBob = result.includes("Bob");
      let hasCharlie = result.includes("Charlie");
      return Jest.Expect.toEqual(Jest.Expect.expect([
        result.length,
        hasAlice,
        hasBob,
        hasCharlie
      ]), [
        3,
        true,
        true,
        true
      ]);
    });
    Jest.test("transforms node data", () => {
      let g = G.makeGraph(undefined);
      G.addNode(g, "Alice", {
        age: 30
      });
      G.addNode(g, "Bob", {
        age: 25
      });
      let ages = G.NodesIter.mapNodes(g, (_node, attr) => attr.age);
      let has30 = ages.includes(30);
      let has25 = ages.includes(25);
      return Jest.Expect.toEqual(Jest.Expect.expect([
        has30,
        has25
      ]), [
        true,
        true
      ]);
    });
    Jest.test("returns empty array for empty graph", () => {
      let g = G.makeGraph(undefined);
      let result = G.NodesIter.mapNodes(g, (node, _attr) => node);
      return Jest.Expect.toEqual(Jest.Expect.expect(result), []);
    });
    Jest.test("can create complex objects from nodes", () => {
      let g = G.makeGraph(undefined);
      G.addNode(g, "Alice", {
        age: 30,
        city: "NYC"
      });
      G.addNode(g, "Bob", {
        age: 25,
        city: "LA"
      });
      let result = G.NodesIter.mapNodes(g, (node, attr) => ({
        name: node,
        age: attr.age,
        city: attr.city
      }));
      return Jest.Expect.toBe(Jest.Expect.expect(result.length), 2);
    });
  });
  Jest.describe("filterNodes", () => {
    Jest.test("filters nodes by predicate", () => {
      let g = G.makeGraph(undefined);
      G.addNode(g, "Alice", {
        age: 30
      });
      G.addNode(g, "Bob", {
        age: 25
      });
      G.addNode(g, "Charlie", {
        age: 35
      });
      let result = G.NodesIter.filterNodes(g, (_node, attr) => attr.age > 28);
      let hasAlice = result.includes("Alice");
      let hasCharlie = result.includes("Charlie");
      return Jest.Expect.toEqual(Jest.Expect.expect([
        result.length,
        hasAlice,
        hasCharlie
      ]), [
        2,
        true,
        true
      ]);
    });
    Jest.test("returns all nodes when predicate is true", () => {
      let g = G.makeGraph(undefined);
      G.addNode(g, "Alice", undefined);
      G.addNode(g, "Bob", undefined);
      let result = G.NodesIter.filterNodes(g, (_node, _attr) => true);
      return Jest.Expect.toBe(Jest.Expect.expect(result.length), 2);
    });
    Jest.test("returns empty array when predicate is false", () => {
      let g = G.makeGraph(undefined);
      G.addNode(g, "Alice", undefined);
      G.addNode(g, "Bob", undefined);
      let result = G.NodesIter.filterNodes(g, (_node, _attr) => false);
      return Jest.Expect.toEqual(Jest.Expect.expect(result), []);
    });
    Jest.test("filters by node name", () => {
      let g = G.makeGraph(undefined);
      G.addNode(g, "Alice", undefined);
      G.addNode(g, "Bob", undefined);
      G.addNode(g, "Alex", undefined);
      let result = G.NodesIter.filterNodes(g, (node, _attr) => node.startsWith("A"));
      let hasAlice = result.includes("Alice");
      let hasAlex = result.includes("Alex");
      return Jest.Expect.toEqual(Jest.Expect.expect([
        result.length,
        hasAlice,
        hasAlex
      ]), [
        2,
        true,
        true
      ]);
    });
    Jest.test("returns empty array for empty graph", () => {
      let g = G.makeGraph(undefined);
      let result = G.NodesIter.filterNodes(g, (_node, _attr) => true);
      return Jest.Expect.toEqual(Jest.Expect.expect(result), []);
    });
  });
  Jest.describe("reduceNodes", () => {
    Jest.test("collects nodes matching condition", () => {
      let g = G.makeGraph(undefined);
      G.addNode(g, "Alice", {
        score: 10
      });
      G.addNode(g, "Bob", {
        score: 20
      });
      G.addNode(g, "Charlie", {
        score: 15
      });
      let result = G.NodesIter.reduceNodes(g, (acc, node, attr) => {
        if (attr.score > 12) {
          return acc.concat([node]);
        } else {
          return acc;
        }
      }, []);
      let hasBob = result.includes("Bob");
      let hasCharlie = result.includes("Charlie");
      return Jest.Expect.toEqual(Jest.Expect.expect([
        result.length,
        hasBob,
        hasCharlie
      ]), [
        2,
        true,
        true
      ]);
    });
    Jest.test("filters and collects node names", () => {
      let g = G.makeGraph(undefined);
      G.addNode(g, "Alice", undefined);
      G.addNode(g, "Bob", undefined);
      G.addNode(g, "Alex", undefined);
      let result = G.NodesIter.reduceNodes(g, (acc, node, _attr) => {
        if (node.startsWith("A")) {
          return acc.concat([node]);
        } else {
          return acc;
        }
      }, []);
      let hasAlice = result.includes("Alice");
      let hasAlex = result.includes("Alex");
      return Jest.Expect.toEqual(Jest.Expect.expect([
        result.length,
        hasAlice,
        hasAlex
      ]), [
        2,
        true,
        true
      ]);
    });
    Jest.test("returns empty array for empty graph", () => {
      let g = G.makeGraph(undefined);
      let result = G.NodesIter.reduceNodes(g, (acc, node, _attr) => acc.concat([node]), []);
      return Jest.Expect.toEqual(Jest.Expect.expect(result), []);
    });
    Jest.test("collects all nodes", () => {
      let g = G.makeGraph(undefined);
      G.addNode(g, "Alice", {
        age: 30
      });
      G.addNode(g, "Bob", {
        age: 25
      });
      G.addNode(g, "Charlie", {
        age: 35
      });
      let result = G.NodesIter.reduceNodes(g, (acc, node, _attr) => acc.concat([node]), []);
      return Jest.Expect.toBe(Jest.Expect.expect(result.length), 3);
    });
  });
  Jest.describe("findNode", () => {
    Jest.test("finds first node matching predicate", () => {
      let g = G.makeGraph(undefined);
      G.addNode(g, "Alice", {
        age: 30
      });
      G.addNode(g, "Bob", {
        age: 25
      });
      G.addNode(g, "Charlie", {
        age: 35
      });
      let result = G.NodesIter.findNode(g, (_node, attr) => attr.age > 28);
      if (result == null) {
        return Jest.fail("Expected to find a node");
      }
      let isValid = [
        "Alice",
        "Charlie"
      ].includes(result);
      return Jest.Expect.toBe(Jest.Expect.expect(isValid), true);
    });
    Jest.test("finds node by name", () => {
      let g = G.makeGraph(undefined);
      G.addNode(g, "Alice", undefined);
      G.addNode(g, "Bob", undefined);
      let result = G.NodesIter.findNode(g, (node, _attr) => node === "Bob");
      return Jest.Expect.toEqual(Jest.Expect.expect(result), "Bob");
    });
    Jest.test("finds node by attribute value", () => {
      let g = G.makeGraph(undefined);
      G.addNode(g, "Alice", {
        role: "admin"
      });
      G.addNode(g, "Bob", {
        role: "user"
      });
      G.addNode(g, "Charlie", {
        role: "admin"
      });
      let result = G.NodesIter.findNode(g, (_node, attr) => attr.role === "admin");
      if (result == null) {
        return Jest.fail("Expected to find a node");
      }
      let isValid = [
        "Alice",
        "Charlie"
      ].includes(result);
      return Jest.Expect.toBe(Jest.Expect.expect(isValid), true);
    });
  });
  Jest.describe("someNode", () => {
    Jest.test("returns true if any node matches", () => {
      let g = G.makeGraph(undefined);
      G.addNode(g, "Alice", {
        age: 30
      });
      G.addNode(g, "Bob", {
        age: 25
      });
      let result = G.NodesIter.someNode(g, (_node, attr) => attr.age > 28);
      return Jest.Expect.toBe(Jest.Expect.expect(result), true);
    });
    Jest.test("returns false if no node matches", () => {
      let g = G.makeGraph(undefined);
      G.addNode(g, "Alice", {
        age: 30
      });
      G.addNode(g, "Bob", {
        age: 25
      });
      let result = G.NodesIter.someNode(g, (_node, attr) => attr.age > 40);
      return Jest.Expect.toBe(Jest.Expect.expect(result), false);
    });
    Jest.test("returns false for empty graph", () => {
      let g = G.makeGraph(undefined);
      let result = G.NodesIter.someNode(g, (_node, _attr) => true);
      return Jest.Expect.toBe(Jest.Expect.expect(result), false);
    });
    Jest.test("checks node existence by name", () => {
      let g = G.makeGraph(undefined);
      G.addNode(g, "Alice", undefined);
      G.addNode(g, "Bob", undefined);
      let hasAlice = G.NodesIter.someNode(g, (node, _attr) => node === "Alice");
      let hasCharlie = G.NodesIter.someNode(g, (node, _attr) => node === "Charlie");
      return Jest.Expect.toEqual(Jest.Expect.expect([
        hasAlice,
        hasCharlie
      ]), [
        true,
        false
      ]);
    });
  });
  Jest.describe("everyNode", () => {
    Jest.test("returns true if all nodes match", () => {
      let g = G.makeGraph(undefined);
      G.addNode(g, "Alice", {
        age: 30
      });
      G.addNode(g, "Bob", {
        age: 25
      });
      G.addNode(g, "Charlie", {
        age: 35
      });
      let result = G.NodesIter.everyNode(g, (_node, attr) => attr.age > 20);
      return Jest.Expect.toBe(Jest.Expect.expect(result), true);
    });
    Jest.test("returns false if any node doesn't match", () => {
      let g = G.makeGraph(undefined);
      G.addNode(g, "Alice", {
        age: 30
      });
      G.addNode(g, "Bob", {
        age: 25
      });
      G.addNode(g, "Charlie", {
        age: 18
      });
      let result = G.NodesIter.everyNode(g, (_node, attr) => attr.age > 20);
      return Jest.Expect.toBe(Jest.Expect.expect(result), false);
    });
    Jest.test("returns true for empty graph", () => {
      let g = G.makeGraph(undefined);
      let result = G.NodesIter.everyNode(g, (_node, _attr) => false);
      return Jest.Expect.toBe(Jest.Expect.expect(result), true);
    });
    Jest.test("validates all nodes meet condition", () => {
      let g = G.makeGraph(undefined);
      G.addNode(g, "Alice", {
        age: 30
      });
      G.addNode(g, "Bob", {
        age: 25
      });
      let allHaveValidAge = G.NodesIter.everyNode(g, (_node, attr) => attr.age >= 0);
      return Jest.Expect.toBe(Jest.Expect.expect(allHaveValidAge), true);
    });
  });
  Jest.describe("nodeEntries", () => {
    Jest.test("returns iterator for empty graph", () => {
      let g = G.makeGraph(undefined);
      let iter = G.NodesIter.nodeEntries(g);
      let next = iter.next();
      return Jest.Expect.toBe(Jest.Expect.expect(next.done), true);
    });
    Jest.test("iterates over node entries", () => {
      let g = G.makeGraph(undefined);
      G.addNode(g, "Alice", {
        age: 30
      });
      G.addNode(g, "Bob", {
        age: 25
      });
      let iter = G.NodesIter.nodeEntries(g);
      let nodes = [];
      let collect = () => {
        while (true) {
          let next = iter.next();
          if (next.done) {
            return;
          }
          let entry = next.value;
          if (entry === undefined) {
            return;
          }
          nodes.push(entry.node);
          continue;
        };
      };
      collect();
      let hasAlice = nodes.includes("Alice");
      let hasBob = nodes.includes("Bob");
      return Jest.Expect.toEqual(Jest.Expect.expect([
        nodes.length,
        hasAlice,
        hasBob
      ]), [
        2,
        true,
        true
      ]);
    });
    Jest.test("provides node and attributes", () => {
      let g = G.makeGraph(undefined);
      G.addNode(g, "Alice", {
        age: 30,
        city: "NYC"
      });
      let iter = G.NodesIter.nodeEntries(g);
      let next = iter.next();
      let entry = next.value;
      if (entry !== undefined) {
        return Jest.Expect.toEqual(Jest.Expect.expect([
          next.done,
          entry.node,
          entry.attributes.age,
          entry.attributes.city
        ]), [
          false,
          "Alice",
          30,
          "NYC"
        ]);
      } else {
        return Jest.fail("Expected entry value");
      }
    });
    Jest.test("iterator respects JS iterator protocol", () => {
      let g = G.makeGraph(undefined);
      G.addNode(g, "Alice", undefined);
      G.addNode(g, "Bob", undefined);
      G.addNode(g, "Charlie", undefined);
      let iter = G.NodesIter.nodeEntries(g);
      let count = {
        contents: 0
      };
      let iterate = () => {
        while (true) {
          let next = iter.next();
          if (next.done) {
            return;
          }
          count.contents = count.contents + 1 | 0;
          continue;
        };
      };
      iterate();
      return Jest.Expect.toBe(Jest.Expect.expect(count.contents), 3);
    });
    Jest.test("completed iterator stays done", () => {
      let g = G.makeGraph(undefined);
      G.addNode(g, "Alice", undefined);
      let iter = G.NodesIter.nodeEntries(g);
      iter.next();
      let second = iter.next();
      let third = iter.next();
      return Jest.Expect.toEqual(Jest.Expect.expect([
        second.done,
        third.done
      ]), [
        true,
        true
      ]);
    });
  });
  Jest.describe("Integration Tests", () => {
    Jest.test("combines multiple iteration methods", () => {
      let g = G.makeGraph(undefined);
      G.addNode(g, "Alice", {
        age: 30,
        active: true
      });
      G.addNode(g, "Bob", {
        age: 25,
        active: false
      });
      G.addNode(g, "Charlie", {
        age: 35,
        active: true
      });
      let activeUsers = G.NodesIter.filterNodes(g, (_node, attr) => attr.active === true);
      let hasOlderUser = G.NodesIter.someNode(g, (_node, attr) => attr.age > 30);
      let allNodes = G.NodesIter.nodes(g);
      return Jest.Expect.toEqual(Jest.Expect.expect([
        activeUsers.length,
        hasOlderUser,
        allNodes.length
      ]), [
        2,
        true,
        3
      ]);
    });
    Jest.test("iteration after graph modification", () => {
      let g = G.makeGraph(undefined);
      G.addNode(g, "Alice", undefined);
      G.addNode(g, "Bob", undefined);
      G.addNode(g, "Charlie", undefined);
      let initialCount = G.NodesIter.nodes(g).length;
      G.dropNode(g, "Bob");
      let afterDropCount = G.NodesIter.nodes(g).length;
      let remaining = G.NodesIter.filterNodes(g, (node, _attr) => node !== "Alice");
      return Jest.Expect.toEqual(Jest.Expect.expect([
        initialCount,
        afterDropCount,
        remaining
      ]), [
        3,
        2,
        ["Charlie"]
      ]);
    });
    Jest.test("works with directed graph", () => {
      let g = G.makeDirectedGraph();
      G.addNode(g, "A", undefined);
      G.addNode(g, "B", undefined);
      G.addEdge(g, "A", "B", undefined);
      let nodes = G.NodesIter.nodes(g);
      let allValid = G.NodesIter.everyNode(g, (node, _attr) => [
        "A",
        "B"
      ].includes(node));
      return Jest.Expect.toEqual(Jest.Expect.expect([
        nodes.length,
        allValid
      ]), [
        2,
        true
      ]);
    });
    Jest.test("works with multi graph", () => {
      let g = G.makeMultiGraph();
      G.addNode(g, "A", {
        type: "source"
      });
      G.addNode(g, "B", {
        type: "target"
      });
      G.addNode(g, "C", {
        type: "target"
      });
      let targets = G.NodesIter.filterNodes(g, (_node, attr) => attr.type === "target");
      return Jest.Expect.toBe(Jest.Expect.expect(targets.length), 2);
    });
  });
});

/*  Not a pure module */
