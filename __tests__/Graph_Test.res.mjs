// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Jest from "@glennsl/rescript-jest/src/jest.res.mjs";
import * as Graphology__Graph from "../src/Graphology__Graph.res.mjs";

Jest.describe("Graph - Core Operations", () => {
  let G = Graphology__Graph.MakeGraph({});
  Jest.describe("Graph Creation", () => {
    Jest.test("creates an empty graph", () => {
      let g = G.makeGraph(undefined);
      return Jest.Expect.toBe(Jest.Expect.expect(G.order(g)), 0);
    });
    Jest.test("creates a directed graph", () => {
      let g = G.makeDirectedGraph();
      return Jest.Expect.toBe(Jest.Expect.expect(G.type_(g)), "directed");
    });
    Jest.test("creates an undirected graph", () => {
      let g = G.makeUndirectedGraph();
      return Jest.Expect.toBe(Jest.Expect.expect(G.type_(g)), "undirected");
    });
    Jest.test("creates a multi graph", () => {
      let g = G.makeMultiGraph();
      return Jest.Expect.toBe(Jest.Expect.expect(G.multi(g)), true);
    });
    Jest.test("creates graph with options", () => {
      let g = G.makeGraph({
        allowSelfLoops: false,
        multi: true,
        type: "directed"
      });
      return Jest.Expect.toBe(Jest.Expect.expect(G.multi(g)), true);
    });
  });
  Jest.describe("Node Operations", () => {
    Jest.test("adds a node", () => {
      let g = G.makeGraph(undefined);
      G.addNode(g, "Alice", undefined);
      return Jest.Expect.toBe(Jest.Expect.expect(G.hasNode(g, "Alice")), true);
    });
    Jest.test("adds node with attributes", () => {
      let g = G.makeGraph(undefined);
      G.addNode(g, "Alice", {
        age: 30,
        city: "NYC"
      });
      let attr = G.getNodeAttributes(g, "Alice");
      return Jest.Expect.toEqual(Jest.Expect.expect(attr.age), 30);
    });
    Jest.test("counts nodes correctly", () => {
      let g = G.makeGraph(undefined);
      G.addNode(g, "Alice", undefined);
      G.addNode(g, "Bob", undefined);
      G.addNode(g, "Charlie", undefined);
      return Jest.Expect.toBe(Jest.Expect.expect(G.order(g)), 3);
    });
    Jest.test("merges node returns correct tuple", () => {
      let g = G.makeGraph(undefined);
      let match = G.mergeNode(g, "Alice", undefined);
      let match$1 = G.mergeNode(g, "Alice", undefined);
      return Jest.Expect.toEqual(Jest.Expect.expect([
        match[0],
        match[1],
        match$1[1]
      ]), [
        "Alice",
        true,
        false
      ]);
    });
    Jest.test("drops a node", () => {
      let g = G.makeGraph(undefined);
      G.addNode(g, "Alice", undefined);
      G.dropNode(g, "Alice");
      return Jest.Expect.toBe(Jest.Expect.expect(G.hasNode(g, "Alice")), false);
    });
    Jest.test("clears all nodes", () => {
      let g = G.makeGraph(undefined);
      G.addNode(g, "Alice", undefined);
      G.addNode(g, "Bob", undefined);
      G.clear(g);
      return Jest.Expect.toBe(Jest.Expect.expect(G.order(g)), 0);
    });
  });
  Jest.describe("Edge Operations", () => {
    Jest.test("adds an edge", () => {
      let g = G.makeGraph(undefined);
      G.addNode(g, "Alice", undefined);
      G.addNode(g, "Bob", undefined);
      G.addEdge(g, "Alice", "Bob", undefined);
      return Jest.Expect.toBe(Jest.Expect.expect(G.size(g)), 1);
    });
    Jest.test("adds edge with attributes", () => {
      let g = G.makeGraph(undefined);
      G.addNode(g, "Alice", undefined);
      G.addNode(g, "Bob", undefined);
      G.addEdge(g, "Alice", "Bob", {
        weight: 5
      });
      let edge = G.edge(g, "Alice", "Bob");
      let attr = G.getEdgeAttributes(g, edge);
      return Jest.Expect.toEqual(Jest.Expect.expect(attr.weight), 5);
    });
    Jest.test("adds edge with key", () => {
      let g = G.makeGraph(undefined);
      G.addNode(g, "Alice", undefined);
      G.addNode(g, "Bob", undefined);
      G.addEdgeWithKey(g, "e1", "Alice", "Bob", undefined);
      return Jest.Expect.toBe(Jest.Expect.expect(G.hasEdge(g, "e1")), true);
    });
    Jest.test("gets edge source and target", () => {
      let g = G.makeGraph(undefined);
      G.addNode(g, "Alice", undefined);
      G.addNode(g, "Bob", undefined);
      G.addEdgeWithKey(g, "e1", "Alice", "Bob", undefined);
      let source = G.source(g, "e1");
      let target = G.target(g, "e1");
      return Jest.Expect.toEqual(Jest.Expect.expect([
        source,
        target
      ]), [
        "Alice",
        "Bob"
      ]);
    });
    Jest.test("gets edge extremities", () => {
      let g = G.makeGraph(undefined);
      G.addNode(g, "Alice", undefined);
      G.addNode(g, "Bob", undefined);
      G.addEdgeWithKey(g, "e1", "Alice", "Bob", undefined);
      let extremities = G.extremities(g, "e1");
      return Jest.Expect.toEqual(Jest.Expect.expect(extremities), [
        "Alice",
        "Bob"
      ]);
    });
    Jest.test("checks if nodes are neighbors", () => {
      let g = G.makeGraph(undefined);
      G.addNode(g, "Alice", undefined);
      G.addNode(g, "Bob", undefined);
      G.addEdge(g, "Alice", "Bob", undefined);
      return Jest.Expect.toBe(Jest.Expect.expect(G.areNeighbors(g, "Alice", "Bob")), true);
    });
    Jest.test("drops an edge", () => {
      let g = G.makeGraph(undefined);
      G.addNode(g, "Alice", undefined);
      G.addNode(g, "Bob", undefined);
      G.addEdgeWithKey(g, "e1", "Alice", "Bob", undefined);
      G.dropEdge(g, "e1");
      return Jest.Expect.toBe(Jest.Expect.expect(G.hasEdge(g, "e1")), false);
    });
    Jest.test("clears all edges", () => {
      let g = G.makeGraph(undefined);
      G.addNode(g, "Alice", undefined);
      G.addNode(g, "Bob", undefined);
      G.addNode(g, "Charlie", undefined);
      G.addEdge(g, "Alice", "Bob", undefined);
      G.addEdge(g, "Bob", "Charlie", undefined);
      G.clearEdges(g);
      return Jest.Expect.toEqual(Jest.Expect.expect([
        G.size(g),
        G.order(g)
      ]), [
        0,
        3
      ]);
    });
  });
  Jest.describe("Node Attributes", () => {
    Jest.test("sets and gets node attribute", () => {
      let g = G.makeGraph(undefined);
      G.addNode(g, "Alice", undefined);
      G.setNodeAttribute(g, "Alice", "age", 30);
      return Jest.Expect.toEqual(Jest.Expect.expect(G.getNodeAttribute(g, "Alice", "age")), 30);
    });
    Jest.test("checks if node has attribute", () => {
      let g = G.makeGraph(undefined);
      G.addNode(g, "Alice", {
        age: 30
      });
      let hasAge = G.hasNodeAttribute(g, "Alice", "age");
      let hasCity = G.hasNodeAttribute(g, "Alice", "city");
      return Jest.Expect.toEqual(Jest.Expect.expect([
        hasAge,
        hasCity
      ]), [
        true,
        false
      ]);
    });
    Jest.test("removes node attribute", () => {
      let g = G.makeGraph(undefined);
      G.addNode(g, "Alice", {
        age: 30
      });
      G.removeNodeAttribute(g, "Alice", "age");
      return Jest.Expect.toBe(Jest.Expect.expect(G.hasNodeAttribute(g, "Alice", "age")), false);
    });
    Jest.test("replaces node attributes", () => {
      let g = G.makeGraph(undefined);
      G.addNode(g, "Alice", {
        age: 30,
        city: "NYC"
      });
      G.replaceNodeAttributes(g, "Alice", {
        name: "Alice"
      });
      let hasAge = G.hasNodeAttribute(g, "Alice", "age");
      let hasName = G.hasNodeAttribute(g, "Alice", "name");
      return Jest.Expect.toEqual(Jest.Expect.expect([
        hasAge,
        hasName
      ]), [
        false,
        true
      ]);
    });
    Jest.test("merges node attributes", () => {
      let g = G.makeGraph(undefined);
      G.addNode(g, "Alice", {
        age: 30
      });
      G.mergeNodeAttributes(g, "Alice", {
        city: "NYC"
      });
      let hasAge = G.hasNodeAttribute(g, "Alice", "age");
      let hasCity = G.hasNodeAttribute(g, "Alice", "city");
      return Jest.Expect.toEqual(Jest.Expect.expect([
        hasAge,
        hasCity
      ]), [
        true,
        true
      ]);
    });
  });
  Jest.describe("Edge Attributes", () => {
    Jest.test("sets and gets edge attribute", () => {
      let g = G.makeGraph(undefined);
      G.addNode(g, "Alice", undefined);
      G.addNode(g, "Bob", undefined);
      G.addEdgeWithKey(g, "e1", "Alice", "Bob", undefined);
      G.setEdgeAttribute(g, "e1", "weight", 5);
      return Jest.Expect.toEqual(Jest.Expect.expect(G.getEdgeAttribute(g, "e1", "weight")), 5);
    });
    Jest.test("checks if edge has attribute", () => {
      let g = G.makeGraph(undefined);
      G.addNode(g, "Alice", undefined);
      G.addNode(g, "Bob", undefined);
      G.addEdgeWithKey(g, "e1", "Alice", "Bob", {
        weight: 5
      });
      let hasWeight = G.hasEdgeAttribute(g, "e1", "weight");
      let hasColor = G.hasEdgeAttribute(g, "e1", "color");
      return Jest.Expect.toEqual(Jest.Expect.expect([
        hasWeight,
        hasColor
      ]), [
        true,
        false
      ]);
    });
    Jest.test("removes edge attribute", () => {
      let g = G.makeGraph(undefined);
      G.addNode(g, "Alice", undefined);
      G.addNode(g, "Bob", undefined);
      G.addEdgeWithKey(g, "e1", "Alice", "Bob", {
        weight: 5
      });
      G.removeEdgeAttribute(g, "e1", "weight");
      return Jest.Expect.toBe(Jest.Expect.expect(G.hasEdgeAttribute(g, "e1", "weight")), false);
    });
  });
  Jest.describe("Graph Attributes", () => {
    Jest.test("sets and gets graph attribute", () => {
      let g = G.makeGraph(undefined);
      G.setAttribute(g, "name", "MyGraph");
      return Jest.Expect.toEqual(Jest.Expect.expect(G.getAttribute(g, "name")), "MyGraph");
    });
    Jest.test("checks if graph has attribute", () => {
      let g = G.makeGraph(undefined);
      G.setAttribute(g, "name", "MyGraph");
      let hasName = G.hasAttribute(g, "name");
      let hasDesc = G.hasAttribute(g, "description");
      return Jest.Expect.toEqual(Jest.Expect.expect([
        hasName,
        hasDesc
      ]), [
        true,
        false
      ]);
    });
    Jest.test("removes graph attribute", () => {
      let g = G.makeGraph(undefined);
      G.setAttribute(g, "name", "MyGraph");
      G.removeAttribute(g, "name");
      return Jest.Expect.toBe(Jest.Expect.expect(G.hasAttribute(g, "name")), false);
    });
  });
  Jest.describe("Degree Operations", () => {
    Jest.test("calculates node degree", () => {
      let g = G.makeGraph(undefined);
      G.addNode(g, "Alice", undefined);
      G.addNode(g, "Bob", undefined);
      G.addNode(g, "Charlie", undefined);
      G.addEdge(g, "Alice", "Bob", undefined);
      G.addEdge(g, "Alice", "Charlie", undefined);
      return Jest.Expect.toBe(Jest.Expect.expect(G.degree(g, "Alice")), 2);
    });
    Jest.test("handles self-loops in degree", () => {
      let g = G.makeGraph({
        allowSelfLoops: true
      });
      G.addNode(g, "Alice", undefined);
      G.addEdge(g, "Alice", "Alice", undefined);
      let withLoops = G.degree(g, "Alice");
      let withoutLoops = G.degreeWithoutSelfLoops(g, "Alice");
      return Jest.Expect.toEqual(Jest.Expect.expect([
        withLoops,
        withoutLoops
      ]), [
        2,
        0
      ]);
    });
  });
});

Jest.describe("Graph - Node Iteration", () => {
  let G = Graphology__Graph.MakeGraph({});
  Jest.test("iterates over nodes", () => {
    let g = G.makeGraph(undefined);
    G.addNode(g, "Alice", undefined);
    G.addNode(g, "Bob", undefined);
    G.addNode(g, "Charlie", undefined);
    let nodes = G.NodesIter.nodes(g);
    return Jest.Expect.toBe(Jest.Expect.expect(nodes.length), 3);
  });
  Jest.test("forEach over nodes", () => {
    let g = G.makeGraph(undefined);
    G.addNode(g, "Alice", {
      age: 30
    });
    G.addNode(g, "Bob", {
      age: 25
    });
    let sum = {
      contents: 0
    };
    G.NodesIter.forEachNode(g, (param, attr) => {
      sum.contents = sum.contents + attr.age | 0;
    });
    return Jest.Expect.toBe(Jest.Expect.expect(sum.contents), 55);
  });
  Jest.test("maps nodes", () => {
    let g = G.makeGraph(undefined);
    G.addNode(g, "Alice", {
      age: 30
    });
    G.addNode(g, "Bob", {
      age: 25
    });
    let ages = G.NodesIter.mapNodes(g, (param, attr) => attr.age);
    return Jest.Expect.toEqual(Jest.Expect.expect(ages), [
      30,
      25
    ]);
  });
  Jest.test("filters nodes", () => {
    let g = G.makeGraph(undefined);
    G.addNode(g, "Alice", {
      age: 30
    });
    G.addNode(g, "Bob", {
      age: 25
    });
    G.addNode(g, "Charlie", {
      age: 35
    });
    let filtered = G.NodesIter.filterNodes(g, (param, attr) => attr.age > 28);
    return Jest.Expect.toBe(Jest.Expect.expect(filtered.length), 2);
  });
  Jest.test("finds a node", () => {
    let g = G.makeGraph(undefined);
    G.addNode(g, "Alice", {
      age: 30
    });
    G.addNode(g, "Bob", {
      age: 25
    });
    let found = G.NodesIter.findNode(g, (param, attr) => attr.age === 25);
    return Jest.Expect.toBe(Jest.Expect.expect(found), "Bob");
  });
  Jest.test("checks if some node matches predicate", () => {
    let g = G.makeGraph(undefined);
    G.addNode(g, "Alice", {
      age: 30
    });
    G.addNode(g, "Bob", {
      age: 25
    });
    let someOver28 = G.NodesIter.someNode(g, (param, attr) => attr.age > 28);
    let someOver40 = G.NodesIter.someNode(g, (param, attr) => attr.age > 40);
    return Jest.Expect.toEqual(Jest.Expect.expect([
      someOver28,
      someOver40
    ]), [
      true,
      false
    ]);
  });
  Jest.test("checks if every node matches predicate", () => {
    let g = G.makeGraph(undefined);
    G.addNode(g, "Alice", {
      age: 30
    });
    G.addNode(g, "Bob", {
      age: 25
    });
    let everyOver20 = G.NodesIter.everyNode(g, (param, attr) => attr.age > 20);
    let everyOver28 = G.NodesIter.everyNode(g, (param, attr) => attr.age > 28);
    return Jest.Expect.toEqual(Jest.Expect.expect([
      everyOver20,
      everyOver28
    ]), [
      true,
      false
    ]);
  });
});

Jest.describe("Graph - Edge Iteration", () => {
  let G = Graphology__Graph.MakeGraph({});
  Jest.test("iterates over all edges", () => {
    let g = G.makeGraph(undefined);
    G.addNode(g, "Alice", undefined);
    G.addNode(g, "Bob", undefined);
    G.addNode(g, "Charlie", undefined);
    G.addEdgeWithKey(g, "e1", "Alice", "Bob", undefined);
    G.addEdgeWithKey(g, "e2", "Bob", "Charlie", undefined);
    let edges = G.EdgesIter.edges(g, "All");
    return Jest.Expect.toBe(Jest.Expect.expect(edges.length), 2);
  });
  Jest.test("iterates over edges of a node", () => {
    let g = G.makeGraph(undefined);
    G.addNode(g, "Alice", undefined);
    G.addNode(g, "Bob", undefined);
    G.addNode(g, "Charlie", undefined);
    G.addEdge(g, "Alice", "Bob", undefined);
    G.addEdge(g, "Alice", "Charlie", undefined);
    G.addEdge(g, "Bob", "Charlie", undefined);
    let edges = G.EdgesIter.edges(g, {
      TAG: "Node",
      _0: "Alice"
    });
    return Jest.Expect.toBe(Jest.Expect.expect(edges.length), 2);
  });
  Jest.test("iterates over edges between two nodes", () => {
    let g = G.makeGraph({
      multi: true
    });
    G.addNode(g, "Alice", undefined);
    G.addNode(g, "Bob", undefined);
    G.addEdgeWithKey(g, "e1", "Alice", "Bob", undefined);
    G.addEdgeWithKey(g, "e2", "Alice", "Bob", undefined);
    let edges = G.EdgesIter.edges(g, {
      TAG: "FromTo",
      _0: "Alice",
      _1: "Bob"
    });
    return Jest.Expect.toBe(Jest.Expect.expect(edges.length), 2);
  });
});

/*  Not a pure module */
