// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Jest from "@glennsl/rescript-jest/src/jest.res.mjs";
import * as Graphology__Graph from "../src/Graphology__Graph.res.mjs";

Jest.describe("Utils - Assertions", () => {
  let G = Graphology__Graph.MakeGraph({});
  Jest.test("isGraph returns true for valid graph", () => {
    let g = G.makeGraph(undefined);
    return Jest.Expect.toBe(Jest.Expect.expect(G.Utils.isGraph(g)), true);
  });
  Jest.test("isGraph returns false for non-graph object", () => {
    let notGraph = {foo: 'bar'};
    return Jest.Expect.toBe(Jest.Expect.expect(G.Utils.isGraph(notGraph)), false);
  });
  Jest.test("isGraph returns false for null", () => {
    let nullValue = null;
    return Jest.Expect.toBe(Jest.Expect.expect(G.Utils.isGraph(nullValue)), false);
  });
});

Jest.describe("Utils - Introspection", () => {
  let G = Graphology__Graph.MakeGraph({});
  Jest.test("inferMulti detects non-multi graph", () => {
    let g = G.makeGraph(undefined);
    return Jest.Expect.toBe(Jest.Expect.expect(G.Utils.inferMulti(g)), false);
  });
  Jest.test("inferMulti detects non-multi graph by default", () => {
    let g = G.makeGraph({
      multi: true
    });
    return Jest.Expect.toBe(Jest.Expect.expect(G.Utils.inferMulti(g)), false);
  });
  Jest.test("inferMulti detects multi graph from edges", () => {
    let g = G.makeGraph({
      multi: true
    });
    G.addNode(g, "Alice", undefined);
    G.addNode(g, "Bob", undefined);
    G.addEdgeWithKey(g, "e1", "Alice", "Bob", undefined);
    G.addEdgeWithKey(g, "e2", "Alice", "Bob", undefined);
    return Jest.Expect.toBe(Jest.Expect.expect(G.Utils.inferMulti(g)), true);
  });
  Jest.test("inferType detects mixed graph type", () => {
    let g = G.makeGraph(undefined);
    return Jest.Expect.toBe(Jest.Expect.expect(G.Utils.inferType(g)), "mixed");
  });
  Jest.test("inferType detects directed graph type", () => {
    let g = G.makeDirectedGraph();
    return Jest.Expect.toBe(Jest.Expect.expect(G.Utils.inferType(g)), "directed");
  });
  Jest.test("inferType detects undirected graph type", () => {
    let g = G.makeUndirectedGraph();
    return Jest.Expect.toBe(Jest.Expect.expect(G.Utils.inferType(g)), "undirected");
  });
});

Jest.describe("Utils - Typical Edge Patterns: Clique", () => {
  let G = Graphology__Graph.MakeGraph({});
  Jest.test("mergeClique creates complete graph from nodes", () => {
    let g = G.makeUndirectedGraph();
    G.Utils.mergeClique(g, [
      "A",
      "B",
      "C"
    ]);
    let order = G.order(g);
    let size = G.size(g);
    return Jest.Expect.toEqual(Jest.Expect.expect([
      order,
      size
    ]), [
      3,
      3
    ]);
  });
  Jest.test("mergeClique connects all nodes to each other", () => {
    let g = G.makeUndirectedGraph();
    G.Utils.mergeClique(g, [
      "A",
      "B",
      "C",
      "D"
    ]);
    let allConnected = G.areNeighbors(g, "A", "B") && G.areNeighbors(g, "A", "C") && G.areNeighbors(g, "A", "D") && G.areNeighbors(g, "B", "C") && G.areNeighbors(g, "B", "D") && G.areNeighbors(g, "C", "D");
    return Jest.Expect.toBe(Jest.Expect.expect(allConnected), true);
  });
  Jest.test("mergeClique with single node does not add node", () => {
    let g = G.makeGraph(undefined);
    G.Utils.mergeClique(g, ["A"]);
    return Jest.Expect.toEqual(Jest.Expect.expect([
      G.order(g),
      G.size(g)
    ]), [
      0,
      0
    ]);
  });
  Jest.test("mergeClique with two nodes creates single edge", () => {
    let g = G.makeUndirectedGraph();
    G.Utils.mergeClique(g, [
      "A",
      "B"
    ]);
    return Jest.Expect.toEqual(Jest.Expect.expect([
      G.order(g),
      G.size(g)
    ]), [
      2,
      1
    ]);
  });
  Jest.test("mergeClique does not duplicate existing nodes", () => {
    let g = G.makeUndirectedGraph();
    G.addNode(g, "A", undefined);
    G.Utils.mergeClique(g, [
      "A",
      "B",
      "C"
    ]);
    return Jest.Expect.toBe(Jest.Expect.expect(G.order(g)), 3);
  });
});

Jest.describe("Utils - Typical Edge Patterns: Cycle", () => {
  let G = Graphology__Graph.MakeGraph({});
  Jest.test("mergeCycle creates cycle from nodes", () => {
    let g = G.makeUndirectedGraph();
    G.Utils.mergeCycle(g, [
      "A",
      "B",
      "C",
      "D"
    ]);
    let order = G.order(g);
    let size = G.size(g);
    return Jest.Expect.toEqual(Jest.Expect.expect([
      order,
      size
    ]), [
      4,
      4
    ]);
  });
  Jest.test("mergeCycle connects nodes in circular pattern", () => {
    let g = G.makeUndirectedGraph();
    G.Utils.mergeCycle(g, [
      "A",
      "B",
      "C"
    ]);
    let isCycle = G.areNeighbors(g, "A", "B") && G.areNeighbors(g, "B", "C") && G.areNeighbors(g, "C", "A");
    return Jest.Expect.toBe(Jest.Expect.expect(isCycle), true);
  });
  Jest.test("mergeCycle with two nodes creates back-and-forth edge", () => {
    let g = G.makeUndirectedGraph();
    G.Utils.mergeCycle(g, [
      "A",
      "B"
    ]);
    return Jest.Expect.toEqual(Jest.Expect.expect([
      G.order(g),
      G.size(g)
    ]), [
      2,
      1
    ]);
  });
  Jest.test("mergeCycle each node has degree 2", () => {
    let g = G.makeUndirectedGraph();
    G.Utils.mergeCycle(g, [
      "A",
      "B",
      "C",
      "D",
      "E"
    ]);
    let allDegree2 = G.degree(g, "A") === 2 && G.degree(g, "B") === 2 && G.degree(g, "C") === 2 && G.degree(g, "D") === 2 && G.degree(g, "E") === 2;
    return Jest.Expect.toBe(Jest.Expect.expect(allDegree2), true);
  });
});

Jest.describe("Utils - Typical Edge Patterns: Path", () => {
  let G = Graphology__Graph.MakeGraph({});
  Jest.test("mergePath creates path from nodes", () => {
    let g = G.makeUndirectedGraph();
    G.Utils.mergePath(g, [
      "A",
      "B",
      "C",
      "D"
    ]);
    let order = G.order(g);
    let size = G.size(g);
    return Jest.Expect.toEqual(Jest.Expect.expect([
      order,
      size
    ]), [
      4,
      3
    ]);
  });
  Jest.test("mergePath connects nodes in linear sequence", () => {
    let g = G.makeUndirectedGraph();
    G.Utils.mergePath(g, [
      "A",
      "B",
      "C",
      "D"
    ]);
    let isPath = G.areNeighbors(g, "A", "B") && G.areNeighbors(g, "B", "C") && G.areNeighbors(g, "C", "D") && !G.areNeighbors(g, "A", "C") && !G.areNeighbors(g, "A", "D");
    return Jest.Expect.toBe(Jest.Expect.expect(isPath), true);
  });
  Jest.test("mergePath with single node creates isolated node", () => {
    let g = G.makeGraph(undefined);
    G.Utils.mergePath(g, ["A"]);
    return Jest.Expect.toEqual(Jest.Expect.expect([
      G.order(g),
      G.size(g)
    ]), [
      1,
      0
    ]);
  });
  Jest.test("mergePath endpoints have degree 1", () => {
    let g = G.makeUndirectedGraph();
    G.Utils.mergePath(g, [
      "A",
      "B",
      "C",
      "D",
      "E"
    ]);
    let endpointsDegree1 = G.degree(g, "A") === 1 && G.degree(g, "E") === 1;
    let middleNodesDegree2 = G.degree(g, "B") === 2 && G.degree(g, "C") === 2 && G.degree(g, "D") === 2;
    return Jest.Expect.toEqual(Jest.Expect.expect([
      endpointsDegree1,
      middleNodesDegree2
    ]), [
      true,
      true
    ]);
  });
});

Jest.describe("Utils - Typical Edge Patterns: Star", () => {
  let G = Graphology__Graph.MakeGraph({});
  Jest.test("mergeStar creates star graph from nodes", () => {
    let g = G.makeUndirectedGraph();
    G.Utils.mergeStar(g, [
      "Center",
      "A",
      "B",
      "C"
    ]);
    let order = G.order(g);
    let size = G.size(g);
    return Jest.Expect.toEqual(Jest.Expect.expect([
      order,
      size
    ]), [
      4,
      3
    ]);
  });
  Jest.test("mergeStar connects all nodes to first node", () => {
    let g = G.makeUndirectedGraph();
    G.Utils.mergeStar(g, [
      "Center",
      "A",
      "B",
      "C"
    ]);
    let isStar = G.areNeighbors(g, "Center", "A") && G.areNeighbors(g, "Center", "B") && G.areNeighbors(g, "Center", "C") && !G.areNeighbors(g, "A", "B") && !G.areNeighbors(g, "B", "C");
    return Jest.Expect.toBe(Jest.Expect.expect(isStar), true);
  });
  Jest.test("mergeStar center has degree n-1", () => {
    let g = G.makeUndirectedGraph();
    G.Utils.mergeStar(g, [
      "Center",
      "A",
      "B",
      "C",
      "D",
      "E"
    ]);
    let centerDegree = G.degree(g, "Center");
    let leafDegree = G.degree(g, "A");
    return Jest.Expect.toEqual(Jest.Expect.expect([
      centerDegree,
      leafDegree
    ]), [
      5,
      1
    ]);
  });
  Jest.test("mergeStar with two nodes creates single edge", () => {
    let g = G.makeUndirectedGraph();
    G.Utils.mergeStar(g, [
      "A",
      "B"
    ]);
    return Jest.Expect.toEqual(Jest.Expect.expect([
      G.order(g),
      G.size(g)
    ]), [
      2,
      1
    ]);
  });
  Jest.test("mergeStar with one node creates isolated node", () => {
    let g = G.makeGraph(undefined);
    G.Utils.mergeStar(g, ["A"]);
    return Jest.Expect.toEqual(Jest.Expect.expect([
      G.order(g),
      G.size(g)
    ]), [
      1,
      0
    ]);
  });
});

Jest.describe("Utils - Miscellaneous: renameGraphKeys", () => {
  let G = Graphology__Graph.MakeGraph({});
  Jest.test("renameGraphKeys renames nodes", () => {
    let g = G.makeGraph(undefined);
    G.addNode(g, "A", undefined);
    G.addNode(g, "B", undefined);
    G.addEdgeWithKey(g, "e1", "A", "B", undefined);
    let nodeMapping = Object.fromEntries([
      [
        "A",
        "X"
      ],
      [
        "B",
        "Y"
      ]
    ]);
    let edgeMapping = Object.fromEntries([]);
    let g2 = G.Utils.renameGraphKeys(g, nodeMapping, edgeMapping);
    let hasOldNodes = G.hasNode(g2, "A") || G.hasNode(g2, "B");
    let hasNewNodes = G.hasNode(g2, "X") && G.hasNode(g2, "Y");
    return Jest.Expect.toEqual(Jest.Expect.expect([
      hasOldNodes,
      hasNewNodes
    ]), [
      false,
      true
    ]);
  });
  Jest.test("renameGraphKeys renames edges", () => {
    let g = G.makeGraph(undefined);
    G.addNode(g, "A", undefined);
    G.addNode(g, "B", undefined);
    G.addEdgeWithKey(g, "e1", "A", "B", undefined);
    let nodeMapping = Object.fromEntries([]);
    let edgeMapping = Object.fromEntries([[
        "e1",
        "edge1"
      ]]);
    let g2 = G.Utils.renameGraphKeys(g, nodeMapping, edgeMapping);
    let hasOldEdge = G.hasEdge(g2, "e1");
    let hasNewEdge = G.hasEdge(g2, "edge1");
    return Jest.Expect.toEqual(Jest.Expect.expect([
      hasOldEdge,
      hasNewEdge
    ]), [
      false,
      true
    ]);
  });
  Jest.test("renameGraphKeys preserves node attributes", () => {
    let g = G.makeGraph(undefined);
    G.addNode(g, "A", {
      value: 42
    });
    let nodeMapping = Object.fromEntries([[
        "A",
        "X"
      ]]);
    let edgeMapping = Object.fromEntries([]);
    let g2 = G.Utils.renameGraphKeys(g, nodeMapping, edgeMapping);
    let attr = G.getNodeAttributes(g2, "X");
    return Jest.Expect.toEqual(Jest.Expect.expect(attr.value), 42);
  });
  Jest.test("renameGraphKeys preserves edge attributes", () => {
    let g = G.makeGraph(undefined);
    G.addNode(g, "A", undefined);
    G.addNode(g, "B", undefined);
    G.addEdgeWithKey(g, "e1", "A", "B", {
      weight: 10
    });
    let nodeMapping = Object.fromEntries([]);
    let edgeMapping = Object.fromEntries([[
        "e1",
        "edge1"
      ]]);
    let g2 = G.Utils.renameGraphKeys(g, nodeMapping, edgeMapping);
    let attr = G.getEdgeAttributes(g2, "edge1");
    return Jest.Expect.toEqual(Jest.Expect.expect(attr.weight), 10);
  });
  Jest.test("renameGraphKeys with empty mappings returns copy", () => {
    let g = G.makeGraph(undefined);
    G.addNode(g, "A", undefined);
    G.addNode(g, "B", undefined);
    G.addEdge(g, "A", "B", undefined);
    let nodeMapping = Object.fromEntries([]);
    let edgeMapping = Object.fromEntries([]);
    let g2 = G.Utils.renameGraphKeys(g, nodeMapping, edgeMapping);
    let hasNodes = G.hasNode(g2, "A") && G.hasNode(g2, "B");
    let order = G.order(g2);
    let size = G.size(g2);
    return Jest.Expect.toEqual(Jest.Expect.expect([
      hasNodes,
      order,
      size
    ]), [
      true,
      2,
      1
    ]);
  });
});

Jest.describe("Utils - Miscellaneous: updateGraphKeys", () => {
  let G = Graphology__Graph.MakeGraph({});
  Jest.test("updateGraphKeys updates node keys based on node data", () => {
    let g = G.makeGraph(undefined);
    G.addNode(g, "1", {
      name: "Alice"
    });
    G.addNode(g, "2", {
      name: "Bob"
    });
    G.addEdgeWithKey(g, "e1", "1", "2", undefined);
    let nodeKeyUpdater = (node, attr) => {
      try {
        return attr.name;
      } catch (exn) {
        return node;
      }
    };
    let edgeKeyUpdater = (_edge, _attr) => "e1";
    let g2 = G.Utils.updateGraphKeys(g, nodeKeyUpdater, edgeKeyUpdater);
    let hasNewNodes = G.hasNode(g2, "Alice") && G.hasNode(g2, "Bob");
    let hasOldNodes = G.hasNode(g2, "1") || G.hasNode(g2, "2");
    return Jest.Expect.toEqual(Jest.Expect.expect([
      hasNewNodes,
      hasOldNodes
    ]), [
      true,
      false
    ]);
  });
  Jest.test("updateGraphKeys updates edge keys based on edge data", () => {
    let g = G.makeGraph(undefined);
    G.addNode(g, "A", undefined);
    G.addNode(g, "B", undefined);
    G.addEdgeWithKey(g, "e1", "A", "B", {
      type: "friend"
    });
    let nodeKeyUpdater = (node, _attr) => node;
    let edgeKeyUpdater = (_edge, attr) => {
      try {
        return attr.type;
      } catch (exn) {
        return "unknown";
      }
    };
    let g2 = G.Utils.updateGraphKeys(g, nodeKeyUpdater, edgeKeyUpdater);
    let hasNewEdge = G.hasEdge(g2, "friend");
    let hasOldEdge = G.hasEdge(g2, "e1");
    return Jest.Expect.toEqual(Jest.Expect.expect([
      hasNewEdge,
      hasOldEdge
    ]), [
      true,
      false
    ]);
  });
  Jest.test("updateGraphKeys preserves attributes", () => {
    let g = G.makeGraph(undefined);
    G.addNode(g, "1", {
      value: 100
    });
    let nodeKeyUpdater = (node, _attr) => `node_` + node;
    let edgeKeyUpdater = (edge, _attr) => edge;
    let g2 = G.Utils.updateGraphKeys(g, nodeKeyUpdater, edgeKeyUpdater);
    let attr = G.getNodeAttributes(g2, "node_1");
    return Jest.Expect.toEqual(Jest.Expect.expect(attr.value), 100);
  });
  Jest.test("updateGraphKeys handles graph structure correctly", () => {
    let g = G.makeGraph(undefined);
    G.addNode(g, "A", {
      id: 1
    });
    G.addNode(g, "B", {
      id: 2
    });
    G.addEdgeWithKey(g, "e1", "A", "B", undefined);
    let nodeKeyUpdater = (_node, attr) => {
      let id;
      try {
        id = attr.id;
      } catch (exn) {
        return "unknown";
      }
      return `n` + String(id);
    };
    let edgeKeyUpdater = (edge, _attr) => edge;
    let g2 = G.Utils.updateGraphKeys(g, nodeKeyUpdater, edgeKeyUpdater);
    let hasEdge = G.areNeighbors(g2, "n1", "n2");
    let order = G.order(g2);
    let size = G.size(g2);
    return Jest.Expect.toEqual(Jest.Expect.expect([
      hasEdge,
      order,
      size
    ]), [
      true,
      2,
      1
    ]);
  });
});

Jest.describe("Utils - Integration with Other Operations", () => {
  let G = Graphology__Graph.MakeGraph({});
  Jest.test("pattern functions work with directed graphs", () => {
    let g = G.makeDirectedGraph();
    G.Utils.mergePath(g, [
      "A",
      "B",
      "C"
    ]);
    let hasForwardEdges = G.areNeighbors(g, "A", "B") && G.areNeighbors(g, "B", "C");
    return Jest.Expect.toBe(Jest.Expect.expect(hasForwardEdges), true);
  });
  Jest.test("can apply patterns to existing graph", () => {
    let g = G.makeUndirectedGraph();
    G.addNode(g, "X", undefined);
    G.Utils.mergePath(g, [
      "A",
      "B",
      "C"
    ]);
    let order = G.order(g);
    let hasX = G.hasNode(g, "X");
    return Jest.Expect.toEqual(Jest.Expect.expect([
      order,
      hasX
    ]), [
      4,
      true
    ]);
  });
  Jest.test("pattern functions can be combined", () => {
    let g = G.makeUndirectedGraph();
    G.Utils.mergePath(g, [
      "A",
      "B",
      "C"
    ]);
    G.Utils.mergeStar(g, [
      "C",
      "D",
      "E"
    ]);
    let cDegree = G.degree(g, "C");
    let order = G.order(g);
    return Jest.Expect.toEqual(Jest.Expect.expect([
      order,
      cDegree
    ]), [
      5,
      3
    ]);
  });
  Jest.test("renameGraphKeys maintains graph topology", () => {
    let g = G.makeUndirectedGraph();
    G.Utils.mergePath(g, [
      "A",
      "B",
      "C",
      "D"
    ]);
    let nodeMapping = Object.fromEntries([
      [
        "A",
        "1"
      ],
      [
        "B",
        "2"
      ],
      [
        "C",
        "3"
      ],
      [
        "D",
        "4"
      ]
    ]);
    let edgeMapping = Object.fromEntries([]);
    let g2 = G.Utils.renameGraphKeys(g, nodeMapping, edgeMapping);
    let isPath = G.areNeighbors(g2, "1", "2") && G.areNeighbors(g2, "2", "3") && G.areNeighbors(g2, "3", "4");
    return Jest.Expect.toBe(Jest.Expect.expect(isPath), true);
  });
});

/*  Not a pure module */
