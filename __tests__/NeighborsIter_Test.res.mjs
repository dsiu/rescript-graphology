// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Jest from "@glennsl/rescript-jest/src/jest.res.mjs";
import * as Graphology__Graph from "../src/Graphology__Graph.res.mjs";

Jest.describe("Graph - Neighbors Iterator", () => {
  let G = Graphology__Graph.MakeGraph({});
  Jest.describe("neighbors", () => {
    Jest.test("returns empty array for isolated node", () => {
      let g = G.makeDirectedGraph();
      G.addNode(g, "A", undefined);
      G.addNode(g, "B", undefined);
      return Jest.Expect.toEqual(Jest.Expect.expect(G.NeighborsIter.neighbors(g, {
        TAG: "Node",
        _0: "A"
      })), []);
    });
    Jest.test("returns neighbors between two nodes", () => {
      let g = G.makeDirectedGraph();
      G.addNode(g, "A", undefined);
      G.addNode(g, "B", undefined);
      G.addNode(g, "C", undefined);
      G.addEdge(g, "A", "B", undefined);
      G.addEdge(g, "B", "C", undefined);
      let result = G.NeighborsIter.neighbors(g, {
        TAG: "Node",
        _0: "B"
      });
      let hasA = result.includes("A");
      let hasC = result.includes("C");
      return Jest.Expect.toEqual(Jest.Expect.expect([
        result.length,
        hasA,
        hasC
      ]), [
        2,
        true,
        true
      ]);
    });
    Jest.test("returns neighbors of specific node", () => {
      let g = G.makeDirectedGraph();
      G.addNode(g, "A", undefined);
      G.addNode(g, "B", undefined);
      G.addNode(g, "C", undefined);
      G.addEdge(g, "A", "B", undefined);
      G.addEdge(g, "A", "C", undefined);
      let result = G.NeighborsIter.neighbors(g, {
        TAG: "Node",
        _0: "A"
      });
      let hasB = result.includes("B");
      let hasC = result.includes("C");
      return Jest.Expect.toEqual(Jest.Expect.expect([
        result.length,
        hasB,
        hasC
      ]), [
        2,
        true,
        true
      ]);
    });
  });
  Jest.describe("inNeighbors and outNeighbors", () => {
    Jest.test("distinguishes between incoming and outgoing neighbors", () => {
      let g = G.makeDirectedGraph();
      G.addNode(g, "A", undefined);
      G.addNode(g, "B", undefined);
      G.addNode(g, "C", undefined);
      G.addEdge(g, "A", "B", undefined);
      G.addEdge(g, "C", "B", undefined);
      let inNbrs = G.NeighborsIter.inNeighbors(g, {
        TAG: "Node",
        _0: "B"
      });
      let outNbrs = G.NeighborsIter.outNeighbors(g, {
        TAG: "Node",
        _0: "B"
      });
      let hasA = inNbrs.includes("A");
      let hasC = inNbrs.includes("C");
      return Jest.Expect.toEqual(Jest.Expect.expect([
        inNbrs.length,
        hasA,
        hasC,
        outNbrs.length
      ]), [
        2,
        true,
        true,
        0
      ]);
    });
    Jest.test("handles outgoing neighbors correctly", () => {
      let g = G.makeDirectedGraph();
      G.addNode(g, "A", undefined);
      G.addNode(g, "B", undefined);
      G.addNode(g, "C", undefined);
      G.addEdge(g, "A", "B", undefined);
      G.addEdge(g, "A", "C", undefined);
      let result = G.NeighborsIter.outNeighbors(g, {
        TAG: "Node",
        _0: "A"
      });
      let hasB = result.includes("B");
      let hasC = result.includes("C");
      return Jest.Expect.toEqual(Jest.Expect.expect([
        result.length,
        hasB,
        hasC
      ]), [
        2,
        true,
        true
      ]);
    });
  });
  Jest.describe("forEachNeighbor", () => {
    Jest.test("iterates over all neighbors of node", () => {
      let g = G.makeDirectedGraph();
      G.addNode(g, "A", undefined);
      G.addNode(g, "B", undefined);
      G.addNode(g, "C", undefined);
      G.addEdge(g, "A", "B", undefined);
      G.addEdge(g, "A", "C", undefined);
      let count = {
        contents: 0
      };
      G.NeighborsIter.forEachNeighbor(g, {
        TAG: "Node",
        _0: "A",
        _1: (_neighbor, _attr) => {
          count.contents = count.contents + 1 | 0;
        }
      });
      return Jest.Expect.toBe(Jest.Expect.expect(count.contents), 2);
    });
    Jest.test("provides neighbor node and attributes", () => {
      let g = G.makeDirectedGraph();
      G.addNode(g, "A", undefined);
      G.addNode(g, "B", {
        score: 100
      });
      G.addEdge(g, "A", "B", undefined);
      let neighborName = {
        contents: ""
      };
      let score = {
        contents: 0
      };
      G.NeighborsIter.forEachNeighbor(g, {
        TAG: "Node",
        _0: "A",
        _1: (neighbor, attr) => {
          neighborName.contents = neighbor;
          score.contents = attr.score;
        }
      });
      return Jest.Expect.toEqual(Jest.Expect.expect([
        neighborName.contents,
        score.contents
      ]), [
        "B",
        100
      ]);
    });
    Jest.test("does nothing for isolated node", () => {
      let g = G.makeDirectedGraph();
      G.addNode(g, "A", undefined);
      G.addNode(g, "B", undefined);
      let count = {
        contents: 0
      };
      G.NeighborsIter.forEachNeighbor(g, {
        TAG: "Node",
        _0: "A",
        _1: (_neighbor, _attr) => {
          count.contents = count.contents + 1 | 0;
        }
      });
      return Jest.Expect.toBe(Jest.Expect.expect(count.contents), 0);
    });
  });
  Jest.describe("mapNeighbors", () => {
    Jest.test("maps over neighbors of node", () => {
      let g = G.makeDirectedGraph();
      G.addNode(g, "A", undefined);
      G.addNode(g, "B", undefined);
      G.addNode(g, "C", undefined);
      G.addEdge(g, "A", "B", undefined);
      G.addEdge(g, "A", "C", undefined);
      let result = G.NeighborsIter.mapNeighbors(g, {
        TAG: "Node",
        _0: "A",
        _1: (neighbor, _attr) => neighbor
      });
      let hasB = result.includes("B");
      let hasC = result.includes("C");
      return Jest.Expect.toEqual(Jest.Expect.expect([
        result.length,
        hasB,
        hasC
      ]), [
        2,
        true,
        true
      ]);
    });
    Jest.test("transforms neighbor data", () => {
      let g = G.makeDirectedGraph();
      G.addNode(g, "A", undefined);
      G.addNode(g, "B", {
        score: 10
      });
      G.addNode(g, "C", {
        score: 20
      });
      G.addEdge(g, "A", "B", undefined);
      G.addEdge(g, "A", "C", undefined);
      let scores = G.NeighborsIter.mapNeighbors(g, {
        TAG: "Node",
        _0: "A",
        _1: (_neighbor, attr) => attr.score
      });
      let has10 = scores.includes(10);
      let has20 = scores.includes(20);
      return Jest.Expect.toEqual(Jest.Expect.expect([
        has10,
        has20
      ]), [
        true,
        true
      ]);
    });
    Jest.test("returns empty array for isolated node", () => {
      let g = G.makeDirectedGraph();
      G.addNode(g, "A", undefined);
      G.addNode(g, "B", undefined);
      let result = G.NeighborsIter.mapNeighbors(g, {
        TAG: "Node",
        _0: "A",
        _1: (neighbor, _attr) => neighbor
      });
      return Jest.Expect.toEqual(Jest.Expect.expect(result), []);
    });
  });
  Jest.describe("reduceNeighbors", () => {
    Jest.test("counts neighbors", () => {
      let g = G.makeDirectedGraph();
      G.addNode(g, "A", undefined);
      G.addNode(g, "B", {
        score: 10
      });
      G.addNode(g, "C", {
        score: 20
      });
      G.addEdge(g, "A", "B", undefined);
      G.addEdge(g, "A", "C", undefined);
      let count = G.NeighborsIter.reduceNeighbors(g, {
        TAG: "Node",
        _0: "A",
        _1: (acc, _neighbor, _attr) => acc + 1 | 0,
        _2: 0
      });
      return Jest.Expect.toBe(Jest.Expect.expect(count), 2);
    });
    Jest.test("accumulates target nodes", () => {
      let g = G.makeDirectedGraph();
      G.addNode(g, "A", undefined);
      G.addNode(g, "B", undefined);
      G.addNode(g, "C", undefined);
      G.addEdgeWithKey(g, "e1", "A", "B", undefined);
      G.addEdgeWithKey(g, "e2", "A", "C", undefined);
      let targets = G.NeighborsIter.reduceNeighbors(g, {
        TAG: "Node",
        _0: "A",
        _1: (acc, neighbor, _attr) => acc.concat([neighbor]),
        _2: []
      });
      let hasB = targets.includes("B");
      let hasC = targets.includes("C");
      return Jest.Expect.toEqual(Jest.Expect.expect([
        targets.length,
        hasB,
        hasC
      ]), [
        2,
        true,
        true
      ]);
    });
    Jest.test("returns initial value for isolated node", () => {
      let g = G.makeDirectedGraph();
      G.addNode(g, "A", undefined);
      G.addNode(g, "B", undefined);
      let result = G.NeighborsIter.reduceNeighbors(g, {
        TAG: "Node",
        _0: "A",
        _1: (acc, _neighbor, _attr) => acc + 1 | 0,
        _2: 0
      });
      return Jest.Expect.toBe(Jest.Expect.expect(result), 0);
    });
  });
  Jest.describe("someNeighbor", () => {
    Jest.test("returns true if any neighbor matches", () => {
      let g = G.makeDirectedGraph();
      G.addNode(g, "A", undefined);
      G.addNode(g, "B", {
        score: 10
      });
      G.addNode(g, "C", {
        score: 20
      });
      G.addEdgeWithKey(g, "e1", "A", "B", undefined);
      G.addEdgeWithKey(g, "e2", "A", "C", undefined);
      let result = G.NeighborsIter.someNeighbor(g, {
        TAG: "Node",
        _0: "A",
        _1: (neighbor, _attr) => neighbor === "C"
      });
      return Jest.Expect.toBe(Jest.Expect.expect(result), true);
    });
    Jest.test("returns false if no neighbor matches", () => {
      let g = G.makeDirectedGraph();
      G.addNode(g, "A", undefined);
      G.addNode(g, "B", {
        score: 10
      });
      G.addEdgeWithKey(g, "e1", "A", "B", undefined);
      let result = G.NeighborsIter.someNeighbor(g, {
        TAG: "Node",
        _0: "A",
        _1: (neighbor, _attr) => neighbor === "C"
      });
      return Jest.Expect.toBe(Jest.Expect.expect(result), false);
    });
    Jest.test("returns false for isolated node", () => {
      let g = G.makeDirectedGraph();
      G.addNode(g, "A", undefined);
      G.addNode(g, "B", undefined);
      let result = G.NeighborsIter.someNeighbor(g, {
        TAG: "Node",
        _0: "A",
        _1: (_neighbor, _attr) => true
      });
      return Jest.Expect.toBe(Jest.Expect.expect(result), false);
    });
  });
  Jest.describe("everyNeighbor", () => {
    Jest.test("returns true if all neighbors match", () => {
      let g = G.makeDirectedGraph();
      G.addNode(g, "A", undefined);
      G.addNode(g, "B", {
        score: 20
      });
      G.addNode(g, "C", {
        score: 30
      });
      G.addEdgeWithKey(g, "e1", "A", "B", undefined);
      G.addEdgeWithKey(g, "e2", "A", "C", undefined);
      let result = G.NeighborsIter.everyNeighbor(g, {
        TAG: "Node",
        _0: "A",
        _1: (neighbor, _attr) => [
          "B",
          "C"
        ].includes(neighbor)
      });
      return Jest.Expect.toBe(Jest.Expect.expect(result), true);
    });
    Jest.test("returns false if any neighbor doesn't match", () => {
      let g = G.makeDirectedGraph();
      G.addNode(g, "A", undefined);
      G.addNode(g, "B", {
        score: 10
      });
      G.addNode(g, "C", {
        score: 30
      });
      G.addEdgeWithKey(g, "e1", "A", "B", undefined);
      G.addEdgeWithKey(g, "e2", "A", "C", undefined);
      let result = G.NeighborsIter.everyNeighbor(g, {
        TAG: "Node",
        _0: "A",
        _1: (neighbor, _attr) => neighbor === "B"
      });
      return Jest.Expect.toBe(Jest.Expect.expect(result), false);
    });
    Jest.test("returns true for isolated node", () => {
      let g = G.makeDirectedGraph();
      G.addNode(g, "A", undefined);
      G.addNode(g, "B", undefined);
      let result = G.NeighborsIter.everyNeighbor(g, {
        TAG: "Node",
        _0: "A",
        _1: (_neighbor, _attr) => false
      });
      return Jest.Expect.toBe(Jest.Expect.expect(result), true);
    });
  });
  Jest.describe("neighborEntries", () => {
    Jest.test("returns iterator for node with no neighbors", () => {
      let g = G.makeDirectedGraph();
      G.addNode(g, "A", undefined);
      G.addNode(g, "B", undefined);
      let iter = G.NeighborsIter.neighborEntries(g, {
        TAG: "Node",
        _0: "A"
      });
      let next = iter.next();
      return Jest.Expect.toBe(Jest.Expect.expect(next.done), true);
    });
    Jest.test("iterates over neighbor entries", () => {
      let g = G.makeDirectedGraph();
      G.addNode(g, "A", undefined);
      G.addNode(g, "B", undefined);
      G.addNode(g, "C", undefined);
      G.addEdgeWithKey(g, "e1", "A", "B", undefined);
      G.addEdgeWithKey(g, "e2", "A", "C", undefined);
      let iter = G.NeighborsIter.neighborEntries(g, {
        TAG: "Node",
        _0: "A"
      });
      let count = {
        contents: 0
      };
      let collect = () => {
        while (true) {
          let next = iter.next();
          if (next.done) {
            return;
          }
          count.contents = count.contents + 1 | 0;
          continue;
        };
      };
      collect();
      return Jest.Expect.toBe(Jest.Expect.expect(count.contents), 2);
    });
    Jest.test("provides neighbor entry details", () => {
      let g = G.makeDirectedGraph();
      G.addNode(g, "A", undefined);
      G.addNode(g, "B", {
        role: "friend"
      });
      G.addEdgeWithKey(g, "e1", "A", "B", {
        weight: 10
      });
      let iter = G.NeighborsIter.neighborEntries(g, {
        TAG: "Node",
        _0: "A"
      });
      let next = iter.next();
      let entry = next.value;
      if (entry !== undefined) {
        return Jest.Expect.toEqual(Jest.Expect.expect([
          next.done,
          entry.neighbor
        ]), [
          false,
          "B"
        ]);
      } else {
        return Jest.fail("Expected entry value");
      }
    });
  });
  Jest.describe("inNeighbors and outNeighbors with forEachNeighbor", () => {
    Jest.test("iterates over incoming neighbors", () => {
      let g = G.makeDirectedGraph();
      G.addNode(g, "A", undefined);
      G.addNode(g, "B", undefined);
      G.addNode(g, "C", undefined);
      G.addEdge(g, "A", "B", undefined);
      G.addEdge(g, "C", "B", undefined);
      let count = {
        contents: 0
      };
      G.NeighborsIter.forEachInNeighbor(g, {
        TAG: "Node",
        _0: "B",
        _1: (_neighbor, _attr) => {
          count.contents = count.contents + 1 | 0;
        }
      });
      return Jest.Expect.toBe(Jest.Expect.expect(count.contents), 2);
    });
    Jest.test("iterates over outgoing neighbors", () => {
      let g = G.makeDirectedGraph();
      G.addNode(g, "A", undefined);
      G.addNode(g, "B", undefined);
      G.addNode(g, "C", undefined);
      G.addEdge(g, "A", "B", undefined);
      G.addEdge(g, "A", "C", undefined);
      let neighbors = [];
      G.NeighborsIter.forEachOutNeighbor(g, {
        TAG: "Node",
        _0: "A",
        _1: (neighbor, _attr) => {
          neighbors.push(neighbor);
        }
      });
      let hasB = neighbors.includes("B");
      let hasC = neighbors.includes("C");
      return Jest.Expect.toEqual(Jest.Expect.expect([
        neighbors.length,
        hasB,
        hasC
      ]), [
        2,
        true,
        true
      ]);
    });
  });
  Jest.describe("Integration Tests", () => {
    Jest.test("combines multiple neighbor iteration methods", () => {
      let g = G.makeDirectedGraph();
      G.addNode(g, "A", undefined);
      G.addNode(g, "B", {
        active: true,
        score: 10
      });
      G.addNode(g, "C", {
        active: false,
        score: 20
      });
      G.addNode(g, "D", {
        active: true,
        score: 30
      });
      G.addEdgeWithKey(g, "e1", "A", "B", undefined);
      G.addEdgeWithKey(g, "e2", "A", "C", undefined);
      G.addEdgeWithKey(g, "e3", "A", "D", undefined);
      let neighborCount = G.NeighborsIter.reduceNeighbors(g, {
        TAG: "Node",
        _0: "A",
        _1: (acc, _neighbor, _attr) => acc + 1 | 0,
        _2: 0
      });
      let hasC = G.NeighborsIter.someNeighbor(g, {
        TAG: "Node",
        _0: "A",
        _1: (neighbor, _attr) => neighbor === "C"
      });
      let allNeighbors = G.NeighborsIter.neighbors(g, {
        TAG: "Node",
        _0: "A"
      });
      return Jest.Expect.toEqual(Jest.Expect.expect([
        neighborCount,
        hasC,
        allNeighbors.length
      ]), [
        3,
        true,
        3
      ]);
    });
    Jest.test("works with undirected graph", () => {
      let g = G.makeUndirectedGraph();
      G.addNode(g, "A", undefined);
      G.addNode(g, "B", undefined);
      G.addNode(g, "C", undefined);
      G.addEdge(g, "A", "B", undefined);
      G.addEdge(g, "B", "C", undefined);
      let neighborsOfB = G.NeighborsIter.neighbors(g, {
        TAG: "Node",
        _0: "B"
      });
      let hasA = neighborsOfB.includes("A");
      let hasC = neighborsOfB.includes("C");
      return Jest.Expect.toEqual(Jest.Expect.expect([
        neighborsOfB.length,
        hasA,
        hasC
      ]), [
        2,
        true,
        true
      ]);
    });
    Jest.test("distinguishes in/out neighbors in directed graph", () => {
      let g = G.makeDirectedGraph();
      G.addNode(g, "A", undefined);
      G.addNode(g, "B", undefined);
      G.addNode(g, "C", undefined);
      G.addEdge(g, "A", "B", undefined);
      G.addEdge(g, "B", "C", undefined);
      let inNbrs = G.NeighborsIter.inNeighbors(g, {
        TAG: "Node",
        _0: "B"
      });
      let outNbrs = G.NeighborsIter.outNeighbors(g, {
        TAG: "Node",
        _0: "B"
      });
      let allNbrs = G.NeighborsIter.neighbors(g, {
        TAG: "Node",
        _0: "B"
      });
      return Jest.Expect.toEqual(Jest.Expect.expect([
        inNbrs.length,
        outNbrs.length,
        allNbrs.length
      ]), [
        1,
        1,
        2
      ]);
    });
  });
});

/*  Not a pure module */
