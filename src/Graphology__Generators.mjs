// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Graphology from "graphology";
import * as GraphologyGenerators from "graphology-generators";

function MakeGenerators(C) {
  let classicGraphGenHelper = (fn, graphType, int) => {
    switch (graphType) {
      case "Graph" :
        return fn(Graphology.default.Graph, int);
      case "DirectedGraph" :
        return fn(Graphology.default.DirectedGraph, int);
      case "UndirectedGraph" :
        return fn(Graphology.default.UndirectedGraph, int);
      case "MultiGraph" :
        return fn(Graphology.default.MultiGraph, int);
      case "MultiDirectedGraph" :
        return fn(Graphology.default.MultiDirectedGraph, int);
      case "MultiUndirectedGraph" :
        return fn(Graphology.default.MultiUndirectedGraph, int);
    }
  };
  let complete = (graphType, order) => classicGraphGenHelper((prim0, prim1) => GraphologyGenerators.classic.complete(prim0, prim1), graphType, order);
  let empty = (graphType, order) => classicGraphGenHelper((prim0, prim1) => GraphologyGenerators.classic.empty(prim0, prim1), graphType, order);
  let ladder = (graphType, length) => classicGraphGenHelper((prim0, prim1) => GraphologyGenerators.classic.ladder(prim0, prim1), graphType, length);
  let path = (graphType, order) => classicGraphGenHelper((prim0, prim1) => GraphologyGenerators.classic.path(prim0, prim1), graphType, order);
  let cavemanGraphGenHelper = (fn, graphType, l, k) => {
    switch (graphType) {
      case "Graph" :
        return fn(Graphology.default.Graph, l, k);
      case "DirectedGraph" :
        return fn(Graphology.default.DirectedGraph, l, k);
      case "UndirectedGraph" :
        return fn(Graphology.default.UndirectedGraph, l, k);
      case "MultiGraph" :
        return fn(Graphology.default.MultiGraph, l, k);
      case "MultiDirectedGraph" :
        return fn(Graphology.default.MultiDirectedGraph, l, k);
      case "MultiUndirectedGraph" :
        return fn(Graphology.default.MultiUndirectedGraph, l, k);
    }
  };
  let caveman = (graphType, l, k) => cavemanGraphGenHelper((prim0, prim1, prim2) => GraphologyGenerators.community.caveman(prim0, prim1, prim2), graphType, l, k);
  let connectedCaveman = (graphType, l, k) => cavemanGraphGenHelper((prim0, prim1, prim2) => GraphologyGenerators.community.connectedCaveman(prim0, prim1, prim2), graphType, l, k);
  let graphGenWithOptHelper = (fn, graphType, options) => {
    switch (graphType) {
      case "Graph" :
        return fn(Graphology.default.Graph, options);
      case "DirectedGraph" :
        return fn(Graphology.default.DirectedGraph, options);
      case "UndirectedGraph" :
        return fn(Graphology.default.UndirectedGraph, options);
      case "MultiGraph" :
        return fn(Graphology.default.MultiGraph, options);
      case "MultiDirectedGraph" :
        return fn(Graphology.default.MultiDirectedGraph, options);
      case "MultiUndirectedGraph" :
        return fn(Graphology.default.MultiUndirectedGraph, options);
    }
  };
  let clusters = (graphType, options) => graphGenWithOptHelper((prim0, prim1) => GraphologyGenerators.random.clusters(prim0, prim1), graphType, options);
  let erdosRenyi = (graphType, options) => graphGenWithOptHelper((prim0, prim1) => GraphologyGenerators.random.erdosRenyi(prim0, prim1), graphType, options);
  let girvanNewman = (graphType, options) => graphGenWithOptHelper((prim0, prim1) => GraphologyGenerators.random.girvanNewman(prim0, prim1), graphType, options);
  let graphGenNoOptHelper = (fn, graphType) => {
    switch (graphType) {
      case "Graph" :
        return fn(Graphology.default.Graph);
      case "DirectedGraph" :
        return fn(Graphology.default.DirectedGraph);
      case "UndirectedGraph" :
        return fn(Graphology.default.UndirectedGraph);
      case "MultiGraph" :
        return fn(Graphology.default.MultiGraph);
      case "MultiDirectedGraph" :
        return fn(Graphology.default.MultiDirectedGraph);
      case "MultiUndirectedGraph" :
        return fn(Graphology.default.MultiUndirectedGraph);
    }
  };
  let krackhardtKite = graphType => graphGenNoOptHelper(prim => GraphologyGenerators.small.krackhardtKite(prim), graphType);
  let florentineFamilies = graphType => graphGenNoOptHelper(prim => GraphologyGenerators.social.florentineFamilies(prim), graphType);
  let karateClub = graphType => graphGenNoOptHelper(prim => GraphologyGenerators.social.karateClub(prim), graphType);
  return {
    complete: complete,
    empty: empty,
    ladder: ladder,
    path: path,
    caveman: caveman,
    connectedCaveman: connectedCaveman,
    clusters: clusters,
    erdosRenyi: erdosRenyi,
    girvanNewman: girvanNewman,
    krackhardtKite: krackhardtKite,
    florentineFamilies: florentineFamilies,
    karateClub: karateClub
  };
}

export {
  MakeGenerators,
}
/* graphology Not a pure module */
