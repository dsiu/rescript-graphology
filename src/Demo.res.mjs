// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Nodefs from "node:fs";
import * as Graphology__Graph from "./Graphology__Graph.res.mjs";

function log(prim) {
  console.log(prim);
}

function log2(prim0, prim1) {
  console.log(prim0, prim1);
}

function stringToFile(str, fileName) {
  Nodefs.writeFileSync(fileName, Buffer.from(str));
}

console.log("=== simple graph ===");

let G = Graphology__Graph.MakeGraph({});

let g = G.makeGraph(undefined);

G.addNode(g, "John", undefined);

console.log("=== Traversal ===");

let H = Graphology__Graph.MakeGraph({});

let h = H.makeGraph(undefined);

console.log("hi");

H.addNode(h, "John", {
  lastName: "Doe"
});

H.addNode(h, "Peter", {
  lastName: "Egg"
});

H.addNode(h, "Mary", undefined);

H.addEdge(h, "John", "Peter", {
  dist: 23
});

H.addEdge(h, "Peter", "Mary", {
  dist: 12
});

H.NodesIter.forEachNode(h, (n, attr) => {
  console.log(n);
  console.log(attr);
});

let __x = H.NodesIter.mapNodes(h, (n, attr) => {
  console.log(n);
  console.log(attr);
  return 1;
});

console.log("mapNodes", __x);

H.Traversal.bfs(h, (n, att, depth) => {
  console.log(n);
  console.log(att);
  console.log(depth);
});

H.Traversal.dfs(h, (n, att, depth) => {
  console.log(n);
  console.log(att);
  console.log(depth);
});

H.Traversal.bfsFromNode(h, "John", (n, att, depth) => {
  console.log(n);
  console.log(att);
  console.log(depth);
});

let __x$1 = H.ShortestPath.Unweighted.bidirectional(h, "John", "Mary");

console.log("Unweighted bidirection", __x$1);

let __x$2 = H.ShortestPath.Unweighted.singleSource(h, "John");

console.log("Unweighted singleSource", __x$2);

let __x$3 = H.ShortestPath.Unweighted.singleSourceLength(h, "John");

console.log("Unweighted singleSourceLength", __x$3);

let __x$4 = H.ShortestPath.Unweighted.undirectedSingleSourceLength(h, "John");

console.log("Unweighted undirectedSingleSourceLength", __x$4);

console.log("-- Dijkstra");

let __x$5 = H.ShortestPath.Dijkstra.singleSource(h, "John", undefined);

console.log("Dijkstra singleSource", __x$5);

let dijss = H.ShortestPath.Dijkstra.singleSource(h, "John", undefined);

let __x$6 = Object.keys(dijss);

console.log("k", __x$6);

let __x$7 = Object.values(dijss);

console.log("v", __x$7);

let __x$8 = dijss["John"];

console.log("John", __x$8);

let __x$9 = dijss["Peter"];

console.log("Peter", __x$9);

let __x$10 = dijss["Mary"];

console.log("Mary", __x$10);

console.log("-- AStar");

let prim0 = H.ShortestPath.AStar.bidirectional(h, "John", "Mary", undefined, undefined);

console.log(prim0, "AStar bidirectional");

let T = Graphology__Graph.MakeGraph({});

let t = T.makeGraph(undefined);

T.addNode(t, [
  0,
  0
], {
  lastName: "Doe"
});

T.addNode(t, [
  1,
  1
], {
  lastName: "Egg"
});

T.addNode(t, [
  2,
  2
], {
  lastName: "Klein"
});

T.addEdge(t, [
  0,
  0
], [
  1,
  1
], {
  dist: 23
});

T.addEdge(t, [
  1,
  1
], [
  2,
  2
], {
  dist: 12
});

console.log("=== Shortest Path ===");

let G$1 = Graphology__Graph.MakeGraph({});

let g$1 = G$1.makeGraph(undefined);

G$1.addNode(g$1, 1, undefined);

G$1.addNode(g$1, 2, undefined);

G$1.addNode(g$1, 3, undefined);

G$1.addNode(g$1, 4, undefined);

G$1.addEdge(g$1, 1, 2, {
  weight1: 3
});

G$1.addEdge(g$1, 1, 3, {
  weight1: 2
});

G$1.addEdge(g$1, 2, 4, {
  weight1: 1
});

G$1.addEdge(g$1, 3, 4, {
  weight1: 1
});

let __x$11 = G$1.edge(g$1, 1, 2);

console.log("edge", __x$11);

let __x$12 = G$1.EdgesIter.edges(g$1, "All");

console.log("edges", __x$12);

let __x$13 = G$1.EdgesIter.edges(g$1, {
  TAG: "Node",
  _0: 1
});

console.log("edges", __x$13);

let __x$14 = G$1.ShortestPath.Dijkstra.singleSource(g$1, 1, undefined);

console.log("Dijkstra singleSource", __x$14);

let __x$15 = G$1.ShortestPath.Dijkstra.bidirectional(g$1, 1, 4, {
  NAME: "Attr",
  VAL: "weight1"
});

console.log("Dijkstra bidirectional", __x$15);

let ps = G$1.ShortestPath.Dijkstra.bidirectional(g$1, 1, 4, {
  NAME: "Attr",
  VAL: "weight1"
});

let es = G$1.ShortestPath.Utils.edgePathFromNodePath(g$1, ps);

console.log("es", es);

console.log("=== Layout Circular / write to file ===");

let G$2 = Graphology__Graph.MakeGraph({});

let g$2 = G$2.makeGraph(undefined);

G$2.addNode(g$2, 1, undefined);

G$2.addNode(g$2, 2, undefined);

G$2.addNode(g$2, 3, undefined);

G$2.addNode(g$2, 4, undefined);

G$2.addEdge(g$2, 1, 2, undefined);

G$2.addEdge(g$2, 1, 3, undefined);

G$2.addEdge(g$2, 2, 4, undefined);

G$2.addEdge(g$2, 3, 4, undefined);

G$2.Layout.Circular.circular(g$2, undefined);

G$2.Layout.Circular.assign(g$2, {
  center: 0.7,
  scale: 20.0
});

G$2.SVG.render(g$2, "./graph.svg", {
  margin: 20,
  width: 4096,
  height: 4096
}, () => {
  console.log("DONE writing to file");
});

let G$3 = Graphology__Graph.MakeGraph({});

G$3.makeGraph({
  allowSelfLoops: false,
  multi: true,
  type: "directed"
});

console.log("=== export / import ===");

let G$4 = Graphology__Graph.MakeGraph({});

let g$3 = G$4.makeGraph(undefined);

G$4.mergeNode(g$3, "John", undefined);

G$4.mergeNode(g$3, "John", undefined);

G$4.mergeNode(g$3, "John", {
  eyes: "blue"
});

let g$4 = G$4.makeGraph(undefined);

G$4.mergeEdgeWithKey(g$4, "T->E", "Thomas", "Eric", {
  type: "KNOWS"
});

G$4.setAttribute(g$4, "name", "My Graph");

let exported = G$4.$$export(g$4);

let h$1 = G$4.makeGraph(undefined);

G$4.$$import(h$1, exported, undefined);

G$4.addNode(h$1, "John", undefined);

console.log("=== EdgesIter ===");

let G$5 = Graphology__Graph.MakeGraph({});

let g$5 = G$5.makeGraph({
  multi: true
});

G$5.mergeEdgeWithKey(g$5, "T->R", "Thomas", "Rosaline", undefined);

G$5.mergeEdgeWithKey(g$5, "T->E", "Thomas", "Emmett", undefined);

G$5.mergeEdgeWithKey(g$5, "C->T", "Catherine", "Thomas", undefined);

G$5.mergeEdgeWithKey(g$5, "R->C", "Rosaline", "Catherine", undefined);

G$5.mergeEdgeWithKey(g$5, "J->D1", "John", "Daniel", undefined);

G$5.mergeEdgeWithKey(g$5, "J->D2", "John", "Daniel", undefined);

let __x$16 = G$5.EdgesIter.edges(g$5, "All");

console.log("g-G.edges", __x$16);

let __x$17 = G$5.EdgesIter.edges(g$5, {
  TAG: "Node",
  _0: "Thomas"
});

console.log("g-G.edges('Thomas')", __x$17);

let __x$18 = G$5.EdgesIter.edges(g$5, {
  TAG: "FromTo",
  _0: "John",
  _1: "Daniel"
});

console.log("g-G.edges('John', 'Daniel')", __x$18);

console.log("=== BFS ===");

let G$6 = Graphology__Graph.MakeGraph({});

let g$6 = G$6.makeGraph(undefined);

G$6.mergeEdge(g$6, "1", "2", undefined);

G$6.mergeEdge(g$6, "1", "3", undefined);

G$6.mergeEdge(g$6, "1", "4", undefined);

G$6.mergeEdge(g$6, "2", "5", undefined);

G$6.mergeEdge(g$6, "2", "6", undefined);

G$6.mergeEdge(g$6, "4", "7", undefined);

G$6.mergeEdge(g$6, "4", "8", undefined);

G$6.mergeEdge(g$6, "5", "9", undefined);

G$6.mergeEdge(g$6, "5", "10", undefined);

G$6.mergeEdge(g$6, "7", "11", undefined);

G$6.mergeEdge(g$6, "7", "12", undefined);

G$6.GEXF.write(g$6, {
  formatNode: (key, attributes) => ({
    label: key
  }),
  formatEdge: (key, attributes) => ({
    weight: attributes.weight
  }),
  version: "1.3"
});

G$6.GEXF.write(g$6, {
  version: "1.3"
});

console.log("bfs");

G$6.Traversal.bfs(g$6, (n, att, depth) => {
  console.log(n, depth);
});

let G$7 = Graphology__Graph.MakeGraph({});

let g$7 = G$7.makeGraph(undefined);

G$7.Utils.mergeClique(g$7, [
  1,
  2,
  3
]);

let prim = G$7.EdgesIter.edges(g$7, "All").map(e => G$7.extremities(g$7, e));

console.log(prim);

let g$8 = G$7.makeGraph(undefined);

G$7.Utils.mergeCycle(g$8, [
  1,
  2,
  3,
  4,
  5
]);

let prim$1 = G$7.EdgesIter.edges(g$8, "All").map(e => G$7.extremities(g$8, e));

console.log(prim$1);

let g$9 = G$7.makeGraph(undefined);

G$7.Utils.mergePath(g$9, [
  1,
  2,
  3,
  4,
  5
]);

let prim$2 = G$7.EdgesIter.edges(g$9, "All").map(e => G$7.extremities(g$9, e));

console.log(prim$2);

let g$10 = G$7.makeGraph(undefined);

G$7.Utils.mergeStar(g$10, [
  1,
  2,
  3,
  4,
  5
]);

let prim$3 = G$7.EdgesIter.edges(g$10, "All").map(e => G$7.extremities(g$10, e));

console.log(prim$3);

let G$8 = Graphology__Graph.MakeGraph({});

let g$11 = G$8.makeGraph(undefined);

G$8.addNode(g$11, "Martha", undefined);

G$8.addNode(g$11, "Catherine", undefined);

G$8.addNode(g$11, "John", undefined);

G$8.addEdgeWithKey(g$11, "M->C", "Martha", "Catherine", undefined);

G$8.addEdgeWithKey(g$11, "C->J", "Catherine", "John", undefined);

let nodeMap = {};

nodeMap["Martha"] = 1;

nodeMap["Catherine"] = 2;

nodeMap["John"] = 3;

let edgeMap = {};

edgeMap["M->C"] = "rel1";

edgeMap["C->J"] = "rel2";

let renamedGraph = G$8.Utils.renameGraphKeys(g$11, nodeMap, edgeMap);

let prim$4 = G$8.NodesIter.nodes(renamedGraph);

console.log(prim$4);

let prim$5 = G$8.EdgesIter.edges(renamedGraph, "All");

console.log(prim$5);

console.log("=== updateGraphKeys ===");

let G$9 = Graphology__Graph.MakeGraph({});

let g$12 = G$9.makeGraph(undefined);

G$9.addNode(g$12, "Martha", undefined);

G$9.addNode(g$12, "Catherine", undefined);

G$9.addNode(g$12, "John", undefined);

G$9.addEdgeWithKey(g$12, "M->C", "Martha", "Catherine", undefined);

G$9.addEdgeWithKey(g$12, "C->J", "Catherine", "John", undefined);

let updatedGraph = G$9.Utils.updateGraphKeys(g$12, (key, param) => {
  switch (key) {
    case "Catherine" :
      return 5;
    case "Martha" :
      return 4;
    default:
      return 6;
  }
}, (key, param) => {
  if (key === "M->C") {
    return "rel3";
  } else {
    return "rel4";
  }
});

let prim$6 = G$9.NodesIter.nodes(updatedGraph);

console.log(prim$6);

let prim$7 = G$9.EdgesIter.edges(updatedGraph, "All");

console.log(prim$7);

console.log("=== layout ===");

let G$10 = Graphology__Graph.MakeGraph({});

let g$13 = G$10.makeGraph(undefined);

G$10.addNode(g$13, "Martha", undefined);

G$10.addNode(g$13, "Catherine", undefined);

G$10.addNode(g$13, "John", undefined);

G$10.Layout.CirclePack.assign(g$13, undefined);

G$10.Layout.Rotation.assign(g$13, 10.0, undefined);

G$10.Layout.Utils.collectLayout(g$13, undefined);

G$10.Layout.Utils.collectLayoutAsFlatArray(g$13, undefined);

G$10.Layout.CirclePack.circlePack(g$13, undefined);

G$10.Layout.CirclePack.circlePack(g$13, {
  hierarchyAttributes: [
    "degree",
    "community"
  ]
});

console.log("generators");

let G$11 = Graphology__Graph.MakeGraph({});

G$11.Generators.karateClub("DirectedGraph");

export {
  log,
  log2,
  stringToFile,
}
/*  Not a pure module */
